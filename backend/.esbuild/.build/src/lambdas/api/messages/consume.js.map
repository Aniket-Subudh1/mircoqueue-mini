{
  "version": 3,
  "sources": ["../../../../../../node_modules/nanoid/url-alphabet/index.cjs", "../../../../../../node_modules/nanoid/index.cjs", "../../../../../../node_modules/dotenv/lib/main.js", "../../../../../../src/lambdas/api/messages/consume.ts", "../../../../../../src/common/utils.ts", "../../../../../../src/common/constants.ts", "../../../../../../src/common/errors.ts", "../../../../../../src/data/clients/dynamo-client.ts", "../../../../../../src/data/clients/s3-client.ts", "../../../../../../src/common/logger.ts", "../../../../../../src/data/repositories/message-repository.ts", "../../../../../../src/data/repositories/topic-repository.ts", "../../../../../../src/data/repositories/consumer-repository.ts", "../../../../../../src/services/message-service.ts"],
  "sourcesContent": ["// This alphabet uses `A-Za-z0-9_-` symbols.\n// The order of characters is optimized for better gzip and brotli compression.\n// Same as in non-secure/index.js\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n\nmodule.exports = { urlAlphabet }\n", "let crypto = require('crypto')\n\nlet { urlAlphabet } = require('./url-alphabet/index.cjs')\n\n// It is best to make fewer, larger requests to the crypto module to\n// avoid system call overhead. So, random numbers are generated in a\n// pool. The pool is a Buffer that is larger than the initial random\n// request size by this multiplier. The pool is enlarged if subsequent\n// requests exceed the maximum buffer size.\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\n\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\n\nlet random = bytes => {\n  // `|=` convert `bytes` to number to prevent `valueOf` abusing and pool pollution\n  fillPool((bytes |= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\n\nlet customRandom = (alphabet, defaultSize, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)\n\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (let i = 0; i < step; i++)`.\n      let i = step\n      while (i--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  // `|=` convert `size` to number to prevent `valueOf` abusing and pool pollution\n  fillPool((size |= 0))\n  let id = ''\n  // We are reading directly from the random pool to avoid creating new array\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    id += urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\n\nmodule.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n", "const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  const vaultPath = _vaultPath(options)\n\n  // Parse .env.vault\n  const result = DotenvModule.configDotenv({ path: vaultPath })\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}][INFO] ${message}`)\n}\n\nfunction _warn (message) {\n  console.log(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  _log('Loading env from encrypted .env.vault')\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsedAll, options)\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n    }\n  }\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n", "import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';\nimport { ConsumeMessagesRequest } from '../../../common/types';\nimport { \n  getPathParameter, \n  getQueryParameter, \n  parseIntParameter, \n  formatApiResponse \n} from '../../../common/utils';\nimport { LIMITS } from '../../../common/constants';\nimport { errorHandler } from '../../../common/errors';\nimport messageService from '../../../services/message-service';\nimport logger from '../../../common/logger';\n\nexport const handler = async (\n  event: APIGatewayProxyEvent\n): Promise<APIGatewayProxyResult> => {\n  try {\n    logger.debug('Consume messages request', { event });\n\n    // Get topic ID from path parameters\n    const topicId = getPathParameter(event.pathParameters as Record<string, string>, 'topicId');\n\n    // Get query parameters\n    const queryStringParameters = event.queryStringParameters as Record<string, string> | null;\n    const consumerGroupId = getQueryParameter(queryStringParameters, 'consumerGroupId');\n    \n    // Parse optional parameters\n    let maxMessages = LIMITS.DEFAULT_MESSAGES_PER_CONSUME;\n    let waitTimeSeconds = LIMITS.DEFAULT_WAIT_TIME_SECONDS;\n    \n    if (event.queryStringParameters) {\n      if (event.queryStringParameters.maxMessages) {\n        maxMessages = parseIntParameter(\n          event.queryStringParameters.maxMessages,\n          'maxMessages',\n          1,\n          LIMITS.MAX_MESSAGES_PER_CONSUME\n        );\n      }\n      \n      if (event.queryStringParameters.waitTimeSeconds) {\n        waitTimeSeconds = parseIntParameter(\n          event.queryStringParameters.waitTimeSeconds,\n          'waitTimeSeconds',\n          0,\n          LIMITS.MAX_WAIT_TIME_SECONDS\n        );\n      }\n    }\n\n    // Build request\n    const request: ConsumeMessagesRequest = {\n      consumerGroupId: consumerGroupId as string,\n      maxMessages,\n      waitTimeSeconds,\n    };\n\n    // Consume messages\n    const result = await messageService.consumeMessages(topicId, request);\n\n    // Return success response\n    return formatApiResponse(result);\n  } catch (error) {\n    logger.error('Error consuming messages', { error });\n    return errorHandler(error);\n  }\n};", "import { nanoid } from 'nanoid';\nimport { LIMITS, CONTENT_TYPES } from './constants';\nimport { Errors } from './errors';\n\nexport const generateId = (prefix?: string, length = 16): string => {\n  const id = nanoid(length);\n  return prefix ? `${prefix}_${id}` : id;\n};\n\n\nexport const generateTopicId = (): string => {\n  return generateId('topic');\n};\n\n\nexport const generateMessageId = (): string => {\n  return generateId('msg');\n};\n\n\nexport const generateConsumerGroupId = (): string => {\n  return generateId('consumer');\n};\n\nexport const generatePayloadKey = (topicId: string, messageId: string): string => {\n  const timestamp = Date.now();\n  return `${topicId}/${timestamp}/${messageId}`;\n};\n\n\nexport const validateMessageSize = (payload: string | object): void => {\n  const stringPayload = typeof payload === 'string' \n    ? payload \n    : JSON.stringify(payload);\n  \n  const size = Buffer.byteLength(stringPayload, 'utf8');\n  \n  if (size > LIMITS.MAX_MESSAGE_SIZE_BYTES) {\n    throw Errors.messageTooLarge(size, LIMITS.MAX_MESSAGE_SIZE_BYTES);\n  }\n};\n\n\nexport const validateMetadata = (metadata?: Record<string, string>): void => {\n  if (!metadata) return;\n  \n  const keys = Object.keys(metadata);\n  \n  if (keys.length > LIMITS.MAX_METADATA_KEYS) {\n    throw Errors.validationError(\n      `Metadata cannot have more than ${LIMITS.MAX_METADATA_KEYS} keys`,\n      { field: 'metadata' }\n    );\n  }\n  \n  for (const key of keys) {\n    if (key.length > LIMITS.MAX_METADATA_KEY_LENGTH) {\n      throw Errors.validationError(\n        `Metadata key '${key}' exceeds maximum length of ${LIMITS.MAX_METADATA_KEY_LENGTH}`,\n        { field: 'metadata', key }\n      );\n    }\n    \n    const value = metadata[key];\n    if (value && value.length > LIMITS.MAX_METADATA_VALUE_LENGTH) {\n      throw Errors.validationError(\n        `Metadata value for key '${key}' exceeds maximum length of ${LIMITS.MAX_METADATA_VALUE_LENGTH}`,\n        { field: 'metadata', key }\n      );\n    }\n  }\n};\n\n\nexport const formatResponse = <T>(data: T) => {\n  return {\n    success: true,\n    data,\n  };\n};\n\n\nexport const formatApiResponse = <T>(data: T, statusCode = 200) => {\n  return {\n    statusCode,\n    body: JSON.stringify(formatResponse(data)),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n};\n\nexport const determineContentType = (\n  payload: string | object, \n  contentType?: string\n): string => {\n  if (contentType) return contentType;\n  \n  if (typeof payload === 'string') {\n    try {\n      JSON.parse(payload);\n      return CONTENT_TYPES.JSON;\n    } catch (e) {\n      return CONTENT_TYPES.TEXT;\n    }\n  }\n  \n  return CONTENT_TYPES.JSON;\n};\n\nexport const calculateExpirationTimestamp = (\n  createdAt: number,\n  retentionPeriodHours: number\n): number => {\n  return createdAt + (retentionPeriodHours * 60 * 60 * 1000);\n};\n\n\nexport const parseRequestBody = <T>(body: string | null): T => {\n  if (!body) {\n    throw Errors.validationError('Request body is required');\n  }\n  \n  try {\n    return JSON.parse(body) as T;\n  } catch (error) {\n    throw Errors.validationError('Invalid JSON in request body');\n  }\n};\n\nexport const getPathParameter = (\n  pathParameters: Record<string, string> | null,\n  paramName: string\n): string => {\n  if (!pathParameters || !pathParameters[paramName]) {\n    throw Errors.validationError(`Path parameter '${paramName}' is required`);\n  }\n  \n  return pathParameters[paramName];\n};\n\nexport const getQueryParameter = <T>(\n  queryStringParameters: Record<string, string> | null,\n  paramName: string,\n  defaultValue?: T\n): string | T => {\n  if (!queryStringParameters || !queryStringParameters[paramName]) {\n    if (defaultValue !== undefined) {\n      return defaultValue;\n    }\n    throw Errors.validationError(`Query parameter '${paramName}' is required`);\n  }\n  \n  return queryStringParameters[paramName];\n};\n\nexport const parseIntParameter = (\n  value: string,\n  paramName: string,\n  min?: number,\n  max?: number\n): number => {\n  const parsed = parseInt(value, 10);\n  \n  if (isNaN(parsed)) {\n    throw Errors.validationError(`Parameter '${paramName}' must be a valid integer`);\n  }\n  \n  if (min !== undefined && parsed < min) {\n    throw Errors.validationError(`Parameter '${paramName}' must be at least ${min}`);\n  }\n  \n  if (max !== undefined && parsed > max) {\n    throw Errors.validationError(`Parameter '${paramName}' must be at most ${max}`);\n  }\n  \n  return parsed;\n};", "// Environment names\nexport const ENV = {\n    DEV: 'dev',\n    STAGING: 'staging',\n    PROD: 'prod',\n  };\n  \n  // Current environment\n  export const STAGE = process.env.STAGE || ENV.DEV;\n  \n  // DynamoDB table names\n  export const TABLES = {\n    TOPICS: process.env.TOPICS_TABLE || `MicroQueue-Topics-${STAGE}`,\n    MESSAGES: process.env.MESSAGES_TABLE || `MicroQueue-Messages-${STAGE}`,\n    CONSUMER_GROUPS: process.env.CONSUMER_GROUPS_TABLE || `MicroQueue-ConsumerGroups-${STAGE}`,\n    OFFSETS: process.env.OFFSETS_TABLE || `MicroQueue-Offsets-${STAGE}`,\n  };\n  \n  // S3 bucket names\n  export const BUCKETS = {\n    MESSAGES: process.env.MESSAGES_BUCKET || `microqueue-messages-${STAGE}`,\n    ARCHIVE: process.env.ARCHIVE_BUCKET || `microqueue-archive-${STAGE}`,\n  };\n  \n  // System limits\n  export const LIMITS = {\n    MAX_TOPIC_NAME_LENGTH: 100,\n    MAX_DESCRIPTION_LENGTH: 500,\n    MAX_MESSAGE_SIZE_BYTES: 256 * 1024, // 256KB\n    MAX_METADATA_KEYS: 10,\n    MAX_METADATA_KEY_LENGTH: 128,\n    MAX_METADATA_VALUE_LENGTH: 256,\n    MAX_RETENTION_HOURS: 7 * 24, // 1 week\n    DEFAULT_RETENTION_HOURS: 24, // 1 day\n    MAX_MESSAGES_PER_CONSUME: 100,\n    DEFAULT_MESSAGES_PER_CONSUME: 10,\n    MAX_WAIT_TIME_SECONDS: 20,\n    DEFAULT_WAIT_TIME_SECONDS: 0,\n  };\n  \n  // Error codes\n  export const ERROR_CODES = {\n    // General errors\n    INTERNAL_ERROR: 'INTERNAL_ERROR',\n    VALIDATION_ERROR: 'VALIDATION_ERROR',\n    RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',\n    \n    // Topic errors\n    TOPIC_NOT_FOUND: 'TOPIC_NOT_FOUND',\n    TOPIC_ALREADY_EXISTS: 'TOPIC_ALREADY_EXISTS',\n    \n    // Message errors\n    MESSAGE_NOT_FOUND: 'MESSAGE_NOT_FOUND',\n    MESSAGE_TOO_LARGE: 'MESSAGE_TOO_LARGE',\n    INVALID_MESSAGE_FORMAT: 'INVALID_MESSAGE_FORMAT',\n    \n    // Consumer errors\n    CONSUMER_GROUP_NOT_FOUND: 'CONSUMER_GROUP_NOT_FOUND',\n    CONSUMER_GROUP_ALREADY_EXISTS: 'CONSUMER_GROUP_ALREADY_EXISTS',\n    \n    // System errors\n    RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',\n    SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',\n  };\n  \n  // HTTP Status codes\n  export const HTTP_STATUS = {\n    OK: 200,\n    CREATED: 201,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    CONFLICT: 409,\n    PAYLOAD_TOO_LARGE: 413,\n    UNPROCESSABLE_ENTITY: 422,\n    TOO_MANY_REQUESTS: 429,\n    INTERNAL_SERVER_ERROR: 500,\n    SERVICE_UNAVAILABLE: 503,\n  };\n  \n  // Content types\n  export const CONTENT_TYPES = {\n    JSON: 'application/json',\n    TEXT: 'text/plain',\n    XML: 'application/xml',\n    BINARY: 'application/octet-stream',\n  };\n  \n  // Raft consensus algorithm constants\n  export const RAFT = {\n    HEARTBEAT_INTERVAL_MS: 100,\n    ELECTION_TIMEOUT_MIN_MS: 150,\n    ELECTION_TIMEOUT_MAX_MS: 300,\n    MAX_LOG_ENTRIES_PER_REQUEST: 100,\n  };", "import { MicroQueueError } from './types';\nimport { ERROR_CODES, HTTP_STATUS } from './constants';\n\nexport class AppError extends Error implements MicroQueueError {\n  code: string;\n  statusCode: number;\n  details?: any;\n\n  constructor(code: string, message: string, statusCode: number, details?: any) {\n    super(message);\n    this.code = code;\n    this.statusCode = statusCode;\n    this.details = details;\n    this.name = 'AppError';\n    \n    // Capturing the stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AppError);\n    }\n  }\n\n  \n  toResponse() {\n    return {\n      success: false,\n      error: {\n        code: this.code,\n        message: this.message,\n        details: this.details,\n      },\n    };\n  }\n}\n\nexport const Errors = {\n  // General errors\n  internalError: (message = 'An internal server error occurred', details?: any) => \n    new AppError(ERROR_CODES.INTERNAL_ERROR, message, HTTP_STATUS.INTERNAL_SERVER_ERROR, details),\n  \n  validationError: (message = 'Validation error', details?: any) => \n    new AppError(ERROR_CODES.VALIDATION_ERROR, message, HTTP_STATUS.BAD_REQUEST, details),\n  \n  resourceNotFound: (resource: string, id: string) => \n    new AppError(ERROR_CODES.RESOURCE_NOT_FOUND, `${resource} with id '${id}' not found`, HTTP_STATUS.NOT_FOUND),\n  \n  // Topic errors\n  topicNotFound: (topicId: string) => \n    new AppError(ERROR_CODES.TOPIC_NOT_FOUND, `Topic '${topicId}' not found`, HTTP_STATUS.NOT_FOUND),\n  \n  topicAlreadyExists: (name: string) => \n    new AppError(ERROR_CODES.TOPIC_ALREADY_EXISTS, `Topic with name '${name}' already exists`, HTTP_STATUS.CONFLICT),\n  \n  // Message errors\n  messageNotFound: (messageId: string) => \n    new AppError(ERROR_CODES.MESSAGE_NOT_FOUND, `Message '${messageId}' not found`, HTTP_STATUS.NOT_FOUND),\n  \n  messageTooLarge: (size: number, maxSize: number) => \n    new AppError(\n      ERROR_CODES.MESSAGE_TOO_LARGE, \n      `Message size (${size} bytes) exceeds maximum allowed size (${maxSize} bytes)`, \n      HTTP_STATUS.PAYLOAD_TOO_LARGE\n    ),\n  \n  // Consumer errors\n  consumerGroupNotFound: (groupId: string) => \n    new AppError(ERROR_CODES.CONSUMER_GROUP_NOT_FOUND, `Consumer group '${groupId}' not found`, HTTP_STATUS.NOT_FOUND),\n  \n  consumerGroupAlreadyExists: (name: string, topicId: string) => \n    new AppError(\n      ERROR_CODES.CONSUMER_GROUP_ALREADY_EXISTS, \n      `Consumer group with name '${name}' already exists for topic '${topicId}'`, \n      HTTP_STATUS.CONFLICT\n    ),\n  \n  // System errors\n  rateLimitExceeded: () => \n    new AppError(ERROR_CODES.RATE_LIMIT_EXCEEDED, 'Rate limit exceeded', HTTP_STATUS.TOO_MANY_REQUESTS),\n  \n  serviceUnavailable: (message = 'Service temporarily unavailable') => \n    new AppError(ERROR_CODES.SERVICE_UNAVAILABLE, message, HTTP_STATUS.SERVICE_UNAVAILABLE),\n};\n\n\nexport const errorHandler = (err: any) => {\n  console.error('Error:', err);\n  \n  // If it's already our AppError, return it\n  if (err instanceof AppError) {\n    return {\n      statusCode: err.statusCode,\n      body: JSON.stringify(err.toResponse()),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n  }\n  \n  // Handle specific AWS SDK errors\n  if (err.code === 'ConditionalCheckFailedException') {\n    const appError = Errors.resourceNotFound('Resource', 'unknown');\n    return {\n      statusCode: appError.statusCode,\n      body: JSON.stringify(appError.toResponse()),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n  }\n  \n  // Handle other known AWS errors\n  if (err.code === 'ThrottlingException') {\n    const appError = Errors.rateLimitExceeded();\n    return {\n      statusCode: appError.statusCode,\n      body: JSON.stringify(appError.toResponse()),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n  }\n  \n  // Default to internal server error\n  const appError = Errors.internalError(err.message || 'An unexpected error occurred');\n  return {\n    statusCode: appError.statusCode,\n    body: JSON.stringify(appError.toResponse()),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n};", "import { DynamoDB } from 'aws-sdk';\nimport * as dotenv from 'dotenv';\ndotenv.config();\n\n// Configure DynamoDB client\nconst options: DynamoDB.ClientConfiguration = {\n  region: process.env.AWS_REGION || 'us-east-1',\n  maxRetries: 3,\n  httpOptions: {\n    timeout: 5000,\n  },\n  ...(process.env.IS_LOCAL && {\n    accessKeyId: 'localstack',\n    secretAccessKey: 'localstack',\n  })\n};\n\n\nif (process.env.DYNAMODB_ENDPOINT) {\n  console.log(`Using local DynamoDB endpoint: ${process.env.DYNAMODB_ENDPOINT}`);\n  options.endpoint = process.env.DYNAMODB_ENDPOINT;\n}\n\n\nexport const dynamoClient = new DynamoDB.DocumentClient(options);\n\nexport default dynamoClient;", "import { S3 } from 'aws-sdk';\nimport * as dotenv from 'dotenv';\ndotenv.config();\n\n// Configure S3 client\nconst options: S3.ClientConfiguration = {\n  region: process.env.AWS_REGION || 'us-east-1',\n  maxRetries: 3,\n  httpOptions: {\n    timeout: 10000,\n  }\n};\n\n// Use local endpoint for development if provided\nif (process.env.S3_ENDPOINT) {\n  console.log(`Using local S3 endpoint: ${process.env.S3_ENDPOINT}`);\n  options.endpoint = process.env.S3_ENDPOINT;\n  options.s3ForcePathStyle = true;\n  options.accessKeyId = process.env.AWS_ACCESS_KEY_ID || 'minioadmin';\n  options.secretAccessKey = process.env.AWS_SECRET_ACCESS_KEY || 'minioadmin';\n  options.signatureVersion = 'v4';\n}\n\n// Create S3 client instance\nexport const s3Client = new S3(options);\n\nexport default s3Client;", "import * as dotenv from 'dotenv';\ndotenv.config();\n\n// Log levels\nexport enum LogLevel {\n  ERROR = 0,\n  WARN = 1,\n  INFO = 2,\n  DEBUG = 3,\n}\n\n// Map string log levels to enum\nconst LOG_LEVEL_MAP: Record<string, LogLevel> = {\n  error: LogLevel.ERROR,\n  warn: LogLevel.WARN,\n  info: LogLevel.INFO,\n  debug: LogLevel.DEBUG,\n};\n\n// Get current log level from environment or default to INFO\nconst logLevel = process.env.LOG_LEVEL || 'info';\nconst logFormat = process.env.LOG_FORMAT || 'json';\nconst currentLogLevel = LOG_LEVEL_MAP[logLevel] || LogLevel.INFO;\n\n/**\n * Format log message according to config\n */\nconst formatLogMessage = (level: string, message: string, data?: any): string => {\n  const timestamp = new Date().toISOString();\n  const requestId = process.env.AWS_REQUEST_ID || '-';\n  \n  if (logFormat === 'json') {\n    const logObject = {\n      timestamp,\n      level,\n      message,\n      requestId,\n      service: 'MicroQueue-Mini',\n      version: '1.0.0',\n      env: process.env.STAGE || 'dev',\n      ...(data ? { data } : {}),\n    };\n    \n    return JSON.stringify(logObject);\n  }\n  \n  // Default to plain text format\n  let logMessage = `[${timestamp}] [${level.toUpperCase()}] [${requestId}] ${message}`;\n  \n  if (data) {\n    logMessage += ` ${JSON.stringify(data)}`;\n  }\n  \n  return logMessage;\n};\n\n/**\n * Logger class\n */\nclass Logger {\n  /**\n   * Error level logging\n   */\n  error(message: string, data?: any): void {\n    if (currentLogLevel >= LogLevel.ERROR) {\n      console.error(formatLogMessage('error', message, data));\n    }\n  }\n  \n  /**\n   * Warning level logging\n   */\n  warn(message: string, data?: any): void {\n    if (currentLogLevel >= LogLevel.WARN) {\n      console.warn(formatLogMessage('warn', message, data));\n    }\n  }\n  \n  /**\n   * Info level logging\n   */\n  info(message: string, data?: any): void {\n    if (currentLogLevel >= LogLevel.INFO) {\n      console.info(formatLogMessage('info', message, data));\n    }\n  }\n  \n  /**\n   * Debug level logging\n   */\n  debug(message: string, data?: any): void {\n    if (currentLogLevel >= LogLevel.DEBUG) {\n      console.debug(formatLogMessage('debug', message, data));\n    }\n  }\n}\n\n// Export singleton logger instance\nexport const logger = new Logger();\n\nexport default logger;", "import { dynamoClient } from '../clients/dynamo-client';\nimport { s3Client } from '../clients/s3-client';\nimport { TABLES, BUCKETS } from '../../common/constants';\nimport { Message } from '../../common/types';\nimport { logger } from '../../common/logger';\nimport { Errors } from '../../common/errors';\n\n\nexport const storeMessage = async (\n  message: Message,\n  payload: string | Buffer\n): Promise<Message> => {\n  logger.debug('Storing message', {\n    messageId: message.messageId,\n    topicId: message.topicId,\n  });\n\n  try {\n    // First store the payload in S3\n    await s3Client.putObject({\n      Bucket: BUCKETS.MESSAGES,\n      Key: message.payloadKey,\n      Body: payload,\n      ContentType: message.contentType,\n    }).promise();\n\n    // Then store the message metadata in DynamoDB\n    await dynamoClient.put({\n      TableName: TABLES.MESSAGES,\n      Item: message,\n    }).promise();\n\n    return message;\n  } catch (error) {\n    logger.error('Error storing message', { error, message });\n    throw error;\n  }\n};\n\n\nexport const getMessageById = async (messageId: string): Promise<Message> => {\n  logger.debug('Getting message by ID', { messageId });\n\n  try {\n    const result = await dynamoClient.query({\n      TableName: TABLES.MESSAGES,\n      IndexName: 'MessageIdIndex',\n      KeyConditionExpression: 'messageId = :messageId',\n      ExpressionAttributeValues: {\n        ':messageId': messageId,\n      },\n      Limit: 1,\n    }).promise();\n\n    if (!result.Items || result.Items.length === 0) {\n      throw Errors.messageNotFound(messageId);\n    }\n\n    return result.Items[0] as Message;\n  } catch (error) {\n    logger.error('Error getting message by ID', { error, messageId });\n\n    if ((error as any).code === 'ResourceNotFoundException') {\n      throw Errors.messageNotFound(messageId);\n    }\n\n    throw error;\n  }\n};\n\n\nexport const getMessages = async (\n  topicId: string,\n  fromSequence: number,\n  limit: number\n): Promise<Message[]> => {\n  logger.debug('Getting messages', {\n    topicId,\n    fromSequence,\n    limit,\n  });\n\n  try {\n    const result = await dynamoClient.query({\n      TableName: TABLES.MESSAGES,\n      KeyConditionExpression: 'topicId = :topicId AND sequenceNumber > :seq',\n      ExpressionAttributeValues: {\n        ':topicId': topicId,\n        ':seq': fromSequence,\n      },\n      Limit: limit,\n      ScanIndexForward: true, // Ascending order by sequence number\n    }).promise();\n\n    return (result.Items || []) as Message[];\n  } catch (error) {\n    logger.error('Error getting messages', { error, topicId, fromSequence });\n    throw error;\n  }\n};\n\nexport const getMessagePayload = async (payloadKey: string): Promise<string | Buffer> => {\n  logger.debug('Getting message payload', { payloadKey });\n\n  try {\n    const result = await s3Client.getObject({\n      Bucket: BUCKETS.MESSAGES,\n      Key: payloadKey,\n    }).promise();\n\n    return result.Body as Buffer;\n  } catch (error) {\n    logger.error('Error getting message payload', { error, payloadKey });\n\n    if ((error as any).code === 'NoSuchKey') {\n      throw Errors.resourceNotFound('Message payload', payloadKey);\n    }\n\n    throw error;\n  }\n};\n\n\nexport const deleteMessage = async (message: Message): Promise<void> => {\n  logger.debug('Deleting message', {\n    messageId: message.messageId,\n    topicId: message.topicId,\n  });\n\n  try {\n    // Delete from DynamoDB\n    await dynamoClient.delete({\n      TableName: TABLES.MESSAGES,\n      Key: {\n        topicId: message.topicId,\n        sequenceNumber: message.sequenceNumber,\n      },\n    }).promise();\n\n    // Archive the payload in S3 (copy to archive bucket)\n    await s3Client.copyObject({\n      Bucket: BUCKETS.ARCHIVE,\n      Key: message.payloadKey,\n      CopySource: `${BUCKETS.MESSAGES}/${message.payloadKey}`,\n    }).promise();\n\n    // Delete from messages bucket\n    await s3Client.deleteObject({\n      Bucket: BUCKETS.MESSAGES,\n      Key: message.payloadKey,\n    }).promise();\n  } catch (error) {\n    logger.error('Error deleting message', { error, message });\n    throw error;\n  }\n};\n\n\nexport const getNextSequenceNumber = async (topicId: string): Promise<number> => {\n  logger.debug('Getting next sequence number', { topicId });\n\n  try {\n    // Try to get the topic's current highest sequence number\n    const result = await dynamoClient.query({\n      TableName: TABLES.MESSAGES,\n      KeyConditionExpression: 'topicId = :topicId',\n      ExpressionAttributeValues: {\n        ':topicId': topicId,\n      },\n      Limit: 1,\n      ScanIndexForward: false, // Descending order to get the highest sequence number\n    }).promise();\n\n    // If there are no messages yet, start from 1\n    if (!result.Items || result.Items.length === 0) {\n      return 1;\n    }\n\n    // Otherwise, increment the highest sequence number\n    const highestSequence = (result.Items[0] as Message).sequenceNumber;\n    return highestSequence + 1;\n  } catch (error) {\n    logger.error('Error getting next sequence number', { error, topicId });\n    throw error;\n  }\n};\n\n\nexport const findExpiredMessages = async (batchSize: number): Promise<Message[]> => {\n  logger.debug('Finding expired messages', { batchSize });\n\n  try {\n    const now = Math.floor(Date.now() / 1000); // Current time in seconds\n\n    const result = await dynamoClient.scan({\n      TableName: TABLES.MESSAGES,\n      FilterExpression: 'expiresAt < :now',\n      ExpressionAttributeValues: {\n        ':now': now,\n      },\n      Limit: batchSize,\n    }).promise();\n\n    return (result.Items || []) as Message[];\n  } catch (error) {\n    logger.error('Error finding expired messages', { error });\n    throw error;\n  }\n};\n\nexport default {\n  storeMessage,\n  getMessageById,\n  getMessages,\n  getMessagePayload,\n  deleteMessage,\n  getNextSequenceNumber,\n  findExpiredMessages,\n};", "\nimport { dynamoClient } from '../clients/dynamo-client';\nimport { TABLES } from '../../common/constants';\nimport { Topic } from '../../common/types';\nimport { logger } from '../../common/logger';\nimport { Errors } from '../../common/errors';\n\n\nexport const createTopic = async (topic: Topic): Promise<Topic> => {\n  logger.debug('Creating topic', { topicId: topic.topicId });\n  \n  try {\n    await dynamoClient.put({\n      TableName: TABLES.TOPICS,\n      Item: topic,\n      ConditionExpression: 'attribute_not_exists(topicId)',\n    }).promise();\n    \n    return topic;\n  } catch (error) {\n    logger.error('Error creating topic', { error, topic });\n    \n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.topicAlreadyExists(topic.name);\n    }\n    \n    throw error;\n  }\n};\n\n\nexport const getTopic = async (topicId: string): Promise<Topic> => {\n  logger.debug('Getting topic', { topicId });\n  \n  try {\n    const result = await dynamoClient.get({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n    }).promise();\n    \n    if (!result.Item) {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    return result.Item as Topic;\n  } catch (error) {\n    logger.error('Error getting topic', { error, topicId });\n    \n    if ((error as any).code === 'ResourceNotFoundException') {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    throw error;\n  }\n};\n\nexport const getTopicByName = async (name: string): Promise<Topic | null> => {\n  logger.debug('Getting topic by name', { name });\n  \n  try {\n    const result = await dynamoClient.scan({\n      TableName: TABLES.TOPICS,\n      FilterExpression: '#name = :name',\n      ExpressionAttributeNames: {\n        '#name': 'name',\n      },\n      ExpressionAttributeValues: {\n        ':name': name,\n      },\n      Limit: 1,\n    }).promise();\n    \n    if (result.Items && result.Items.length > 0) {\n      return result.Items[0] as Topic;\n    }\n    \n    return null;\n  } catch (error) {\n    logger.error('Error getting topic by name', { error, name });\n    throw error;\n  }\n};\n\n\nexport const listTopics = async (): Promise<Topic[]> => {\n  logger.debug('Listing topics');\n  \n  try {\n    const result = await dynamoClient.scan({\n      TableName: TABLES.TOPICS,\n    }).promise();\n    \n    return (result.Items || []) as Topic[];\n  } catch (error) {\n    logger.error('Error listing topics', { error });\n    throw error;\n  }\n};\n\n\nexport const deleteTopic = async (topicId: string): Promise<void> => {\n  logger.debug('Deleting topic', { topicId });\n  \n  try {\n    await dynamoClient.delete({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n      ConditionExpression: 'attribute_exists(topicId)',\n    }).promise();\n  } catch (error) {\n    logger.error('Error deleting topic', { error, topicId });\n    \n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    throw error;\n  }\n};\n\n\nexport const incrementMessageCount = async (topicId: string, timestamp: number): Promise<void> => {\n  logger.debug('Incrementing topic message count', { topicId, timestamp });\n  \n  try {\n    await dynamoClient.update({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n      UpdateExpression: 'SET messageCount = messageCount + :inc, lastMessageTimestamp = :ts',\n      ExpressionAttributeValues: {\n        ':inc': 1,\n        ':ts': timestamp,\n      },\n      ConditionExpression: 'attribute_exists(topicId)',\n    }).promise();\n  } catch (error) {\n    logger.error('Error incrementing message count', { error, topicId });\n    \n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    throw error;\n  }\n};\n\n\nexport const updateTopic = async (\n  topicId: string,\n  updates: Partial<Omit<Topic, 'topicId' | 'createdAt'>>\n): Promise<Topic> => {\n  logger.debug('Updating topic', { topicId, updates });\n  \n  // Build update expression\n  const updateExpressions: string[] = [];\n  const expressionAttributeNames: Record<string, string> = {};\n  const expressionAttributeValues: Record<string, any> = {};\n  \n  Object.entries(updates).forEach(([key, value]) => {\n    if (value !== undefined) {\n      updateExpressions.push(`#${key} = :${key}`);\n      expressionAttributeNames[`#${key}`] = key;\n      expressionAttributeValues[`:${key}`] = value;\n    }\n  });\n  \n  if (updateExpressions.length === 0) {\n    return getTopic(topicId);\n  }\n  \n  try {\n    await dynamoClient.update({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n      UpdateExpression: `SET ${updateExpressions.join(', ')}`,\n      ExpressionAttributeNames: expressionAttributeNames,\n      ExpressionAttributeValues: expressionAttributeValues,\n      ConditionExpression: 'attribute_exists(topicId)',\n      ReturnValues: 'NONE',\n    }).promise();\n    \n    return getTopic(topicId);\n  } catch (error) {\n    logger.error('Error updating topic', { error, topicId });\n    \n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    throw error;\n  }\n};\n\nexport default {\n  createTopic,\n  getTopic,\n  getTopicByName,\n  listTopics,\n  deleteTopic,\n  incrementMessageCount,\n  updateTopic,\n};", "import { dynamoClient } from '../clients/dynamo-client';\nimport { TABLES } from '../../common/constants';\nimport { ConsumerGroup, ConsumerOffset } from '../../common/types';\nimport { logger } from '../../common/logger';\nimport { Errors } from '../../common/errors';\n\n\nexport const createConsumerGroup = async (consumerGroup: ConsumerGroup): Promise<ConsumerGroup> => {\n  logger.debug('Creating consumer group', {\n    groupId: consumerGroup.groupId,\n    topicId: consumerGroup.topicId,\n  });\n\n  try {\n    await dynamoClient.put({\n      TableName: TABLES.CONSUMER_GROUPS,\n      Item: consumerGroup,\n      ConditionExpression: 'attribute_not_exists(groupId) AND attribute_not_exists(topicId)',\n    }).promise();\n\n    return consumerGroup;\n  } catch (error) {\n    logger.error('Error creating consumer group', { error, consumerGroup });\n\n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.consumerGroupAlreadyExists(consumerGroup.name, consumerGroup.topicId);\n    }\n\n    throw error;\n  }\n};\n\n\nexport const getConsumerGroup = async (groupId: string, topicId: string): Promise<ConsumerGroup> => {\n  logger.debug('Getting consumer group', { groupId, topicId });\n\n  try {\n    const result = await dynamoClient.get({\n      TableName: TABLES.CONSUMER_GROUPS,\n      Key: { groupId, topicId },\n    }).promise();\n\n    if (!result.Item) {\n      throw Errors.consumerGroupNotFound(groupId);\n    }\n\n    return result.Item as ConsumerGroup;\n  } catch (error) {\n    logger.error('Error getting consumer group', { error, groupId, topicId });\n\n    if ((error as any).code === 'ResourceNotFoundException') {\n      throw Errors.consumerGroupNotFound(groupId);\n    }\n\n    throw error;\n  }\n};\n\n/**\n * Get a consumer group by name for a specific topic\n */\nexport const getConsumerGroupByName = async (\n  name: string,\n  topicId: string\n): Promise<ConsumerGroup | null> => {\n  logger.debug('Getting consumer group by name', { name, topicId });\n\n  try {\n    const result = await dynamoClient.scan({\n      TableName: TABLES.CONSUMER_GROUPS,\n      FilterExpression: '#name = :name AND topicId = :topicId',\n      ExpressionAttributeNames: {\n        '#name': 'name',\n      },\n      ExpressionAttributeValues: {\n        ':name': name,\n        ':topicId': topicId,\n      },\n      Limit: 1,\n    }).promise();\n\n    if (result.Items && result.Items.length > 0) {\n      return result.Items[0] as ConsumerGroup;\n    }\n\n    return null;\n  } catch (error) {\n    logger.error('Error getting consumer group by name', { error, name, topicId });\n    throw error;\n  }\n};\n\n/**\n * List all consumer groups for a topic\n */\nexport const listConsumerGroups = async (topicId: string): Promise<ConsumerGroup[]> => {\n  logger.debug('Listing consumer groups', { topicId });\n\n  try {\n    const result = await dynamoClient.query({\n      TableName: TABLES.CONSUMER_GROUPS,\n      KeyConditionExpression: 'topicId = :topicId',\n      ExpressionAttributeValues: {\n        ':topicId': topicId,\n      },\n    }).promise();\n\n    return (result.Items || []) as ConsumerGroup[];\n  } catch (error) {\n    logger.error('Error listing consumer groups', { error, topicId });\n    throw error;\n  }\n};\n\nexport const deleteConsumerGroup = async (groupId: string, topicId: string): Promise<void> => {\n  logger.debug('Deleting consumer group', { groupId, topicId });\n\n  try {\n    await dynamoClient.delete({\n      TableName: TABLES.CONSUMER_GROUPS,\n      Key: { groupId, topicId },\n      ConditionExpression: 'attribute_exists(groupId) AND attribute_exists(topicId)',\n    }).promise();\n\n    // Also delete any offsets for this consumer group\n    await dynamoClient.delete({\n      TableName: TABLES.OFFSETS,\n      Key: { groupId, topicId },\n    }).promise();\n  } catch (error) {\n    logger.error('Error deleting consumer group', { error, groupId, topicId });\n\n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.consumerGroupNotFound(groupId);\n    }\n\n    throw error;\n  }\n};\n\n\nexport const updateConsumerGroupTimestamp = async (\n  groupId: string,\n  topicId: string,\n  timestamp: number\n): Promise<void> => {\n  logger.debug('Updating consumer group timestamp', { groupId, topicId, timestamp });\n\n  try {\n    await dynamoClient.update({\n      TableName: TABLES.CONSUMER_GROUPS,\n      Key: { groupId, topicId },\n      UpdateExpression: 'SET lastConsumedTimestamp = :ts',\n      ExpressionAttributeValues: {\n        ':ts': timestamp,\n      },\n      ConditionExpression: 'attribute_exists(groupId) AND attribute_exists(topicId)',\n    }).promise();\n  } catch (error) {\n    logger.error('Error updating consumer group timestamp', { error, groupId, topicId });\n\n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.consumerGroupNotFound(groupId);\n    }\n\n    throw error;\n  }\n};\n\nexport const getConsumerOffset = async (\n  groupId: string,\n  topicId: string\n): Promise<ConsumerOffset | null> => {\n  logger.debug('Getting consumer offset', { groupId, topicId });\n\n  try {\n    const result = await dynamoClient.get({\n      TableName: TABLES.OFFSETS,\n      Key: { groupId, topicId },\n    }).promise();\n\n    if (!result.Item) {\n      return null;\n    }\n\n    return result.Item as ConsumerOffset;\n  } catch (error) {\n    logger.error('Error getting consumer offset', { error, groupId, topicId });\n    throw error;\n  }\n};\n\nexport const updateConsumerOffset = async (offset: ConsumerOffset): Promise<void> => {\n  logger.debug('Updating consumer offset', {\n    groupId: offset.groupId,\n    topicId: offset.topicId,\n    sequenceNumber: offset.lastSequenceNumber,\n  });\n\n  try {\n    await dynamoClient.put({\n      TableName: TABLES.OFFSETS,\n      Item: offset,\n    }).promise();\n  } catch (error) {\n    logger.error('Error updating consumer offset', { error, offset });\n    throw error;\n  }\n};\n\nexport default {\n  createConsumerGroup,\n  getConsumerGroup,\n  getConsumerGroupByName,\n  listConsumerGroups,\n  deleteConsumerGroup,\n  updateConsumerGroupTimestamp,\n  getConsumerOffset,\n  updateConsumerOffset,\n};", "import { \n    Message,\n    PublishMessageRequest,\n    PublishMessageResponse,\n    ConsumeMessagesRequest,\n    ConsumeMessagesResponse,\n  } from '../common/types';\n  import { \n    generateMessageId,\n    generatePayloadKey,\n    validateMessageSize,\n    validateMetadata,\n    determineContentType,\n    calculateExpirationTimestamp,\n  } from '../common/utils';\n  import { LIMITS, CONTENT_TYPES } from '../common/constants';\n  import { Errors } from '../common/errors';\n  import messageRepository from '../data/repositories/message-repository';\n  import topicRepository from '../data/repositories/topic-repository';\n  import consumerRepository from '../data/repositories/consumer-repository';\n  import logger from '../common/logger';\n  \n  \n  export const publishMessage = async (\n    topicId: string,\n    request: PublishMessageRequest\n  ): Promise<PublishMessageResponse> => {\n    logger.debug('Publishing message', { topicId });\n  \n    // Validate message payload\n    if (!request.payload) {\n      throw Errors.validationError('Message payload is required');\n    }\n  \n    // Validate message size\n    validateMessageSize(request.payload);\n  \n    // Validate metadata if provided\n    validateMetadata(request.metadata);\n  \n    // Get the topic to ensure it exists and get retention period\n    const topic = await topicRepository.getTopic(topicId);\n  \n    // Get the next sequence number for this topic\n    const sequenceNumber = await messageRepository.getNextSequenceNumber(topicId);\n  \n    // Determine content type\n    const contentType = determineContentType(request.payload, request.contentType);\n  \n    // Generate message ID and payload key\n    const messageId = generateMessageId();\n    const payloadKey = generatePayloadKey(topicId, messageId);\n  \n    // Prepare message payload for storage\n    const payload = typeof request.payload === 'string'\n      ? request.payload\n      : JSON.stringify(request.payload);\n  \n    // Calculate message size\n    const size = Buffer.byteLength(payload, 'utf8');\n  \n    // Calculate expiration timestamp for TTL\n    const timestamp = Date.now();\n    const expiresAt = Math.floor(\n      calculateExpirationTimestamp(timestamp, topic.retentionPeriodHours) / 1000\n    ); // Convert to seconds for DynamoDB TTL\n  \n    // Create message object\n    const message: Message = {\n      messageId,\n      topicId,\n      timestamp,\n      sequenceNumber,\n      payloadKey,\n      contentType,\n      size,\n      metadata: request.metadata,\n      expiresAt,\n    };\n  \n    // Store the message\n    await messageRepository.storeMessage(message, payload);\n  \n    // Update topic message count\n    await topicRepository.incrementMessageCount(topicId, timestamp);\n  \n    // Return the response\n    return {\n      messageId,\n      topicId,\n      timestamp,\n      sequenceNumber,\n    };\n  };\n\n  export const consumeMessages = async (\n    topicId: string,\n    request: ConsumeMessagesRequest\n  ): Promise<ConsumeMessagesResponse> => {\n    logger.debug('Consuming messages', { topicId, request });\n  \n    // Validate request\n    if (!request.consumerGroupId) {\n      throw Errors.validationError('Consumer group ID is required');\n    }\n  \n    // Validate max messages\n    const maxMessages = request.maxMessages || LIMITS.DEFAULT_MESSAGES_PER_CONSUME;\n    if (maxMessages < 1) {\n      throw Errors.validationError('Max messages must be at least 1');\n    }\n    if (maxMessages > LIMITS.MAX_MESSAGES_PER_CONSUME) {\n      throw Errors.validationError(\n        `Max messages cannot exceed ${LIMITS.MAX_MESSAGES_PER_CONSUME}`\n      );\n    }\n  \n    // Validate wait time\n    const waitTimeSeconds = request.waitTimeSeconds || LIMITS.DEFAULT_WAIT_TIME_SECONDS;\n    if (waitTimeSeconds < 0) {\n      throw Errors.validationError('Wait time cannot be negative');\n    }\n    if (waitTimeSeconds > LIMITS.MAX_WAIT_TIME_SECONDS) {\n      throw Errors.validationError(\n        `Wait time cannot exceed ${LIMITS.MAX_WAIT_TIME_SECONDS} seconds`\n      );\n    }\n  \n    // Verify the topic exists\n    await topicRepository.getTopic(topicId);\n  \n    // Verify the consumer group exists\n    await consumerRepository.getConsumerGroup(request.consumerGroupId, topicId);\n  \n    // Get the current offset for this consumer group\n    let fromSequence = 0;\n    const offset = await consumerRepository.getConsumerOffset(request.consumerGroupId, topicId);\n  \n    if (offset) {\n      fromSequence = offset.lastSequenceNumber;\n    }\n  \n    // Get messages from this sequence number\n    let messages = await messageRepository.getMessages(topicId, fromSequence, maxMessages);\n  \n    // If no messages and wait time > 0, implement long polling\n    if (messages.length === 0 && waitTimeSeconds > 0) {\n      const endTime = Date.now() + waitTimeSeconds * 1000;\n      \n      // Poll until we get messages or timeout\n      while (messages.length === 0 && Date.now() < endTime) {\n        // Wait a bit before polling again\n        await new Promise(resolve => setTimeout(resolve, 500));\n        \n        // Try to get messages again\n        messages = await messageRepository.getMessages(topicId, fromSequence, maxMessages);\n      }\n    }\n  \n    // If still no messages, return empty response\n    if (messages.length === 0) {\n      return {\n        messages: [],\n        nextSequenceNumber: fromSequence,\n      };\n    }\n  \n    // Load the payloads for each message\n    const messagesWithPayloads = await Promise.all(\n      messages.map(async (message) => {\n        const payload = await messageRepository.getMessagePayload(message.payloadKey);\n        \n        return {\n          messageId: message.messageId,\n          payload: payload.toString('utf8'),\n          timestamp: message.timestamp,\n          sequenceNumber: message.sequenceNumber,\n          contentType: message.contentType,\n          metadata: message.metadata,\n        };\n      })\n    );\n  \n    // Update the consumer offset\n    const lastMessage = messages[messages.length - 1];\n    await consumerRepository.updateConsumerOffset({\n      groupId: request.consumerGroupId,\n      topicId,\n      lastSequenceNumber: lastMessage.sequenceNumber,\n      lastConsumedTimestamp: Date.now(),\n    });\n  \n    // Update consumer group timestamp\n    await consumerRepository.updateConsumerGroupTimestamp(\n      request.consumerGroupId,\n      topicId,\n      Date.now()\n    );\n  \n    return {\n      messages: messagesWithPayloads,\n      nextSequenceNumber: lastMessage.sequenceNumber + 1,\n    };\n  };\n  \n \n  export const getMessageById = async (messageId: string): Promise<{\n    message: Message;\n    payload: string;\n  }> => {\n    logger.debug('Getting message by ID', { messageId });\n  \n    // Get message metadata\n    const message = await messageRepository.getMessageById(messageId);\n  \n    // Get message payload\n    const payload = await messageRepository.getMessagePayload(message.payloadKey);\n  \n    return {\n      message,\n      payload: payload.toString('utf8'),\n    };\n  };\n  \n\n  export const cleanupExpiredMessages = async (batchSize: number): Promise<number> => {\n    logger.debug('Cleaning up expired messages', { batchSize });\n  \n    // Find expired messages\n    const expiredMessages = await messageRepository.findExpiredMessages(batchSize);\n  \n    // If no expired messages, return 0\n    if (expiredMessages.length === 0) {\n      return 0;\n    }\n  \n    // Delete each message\n    let deletedCount = 0;\n    for (const message of expiredMessages) {\n      try {\n        await messageRepository.deleteMessage(message);\n        deletedCount++;\n      } catch (error) {\n        logger.error('Error deleting expired message', { error, messageId: message.messageId });\n      }\n    }\n  \n    return deletedCount;\n  };\n  \n  export default {\n    publishMessage,\n    consumeMessages,\n    getMessageById,\n    cleanupExpiredMessages,\n  };"],
  "mappings": "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",
  "names": ["require_url_alphabet", "__commonJSMin", "exports", "module", "urlAlphabet", "require_nanoid", "__commonJSMin", "exports", "module", "crypto", "urlAlphabet", "POOL_SIZE_MULTIPLIER", "pool", "poolOffset", "fillPool", "bytes", "random", "customRandom", "alphabet", "defaultSize", "getRandom", "mask", "step", "size", "id", "i", "customAlphabet", "nanoid", "require_main", "__commonJSMin", "exports", "module", "fs", "path", "os", "crypto", "packageJson", "version", "LINE", "parse", "src", "obj", "lines", "match", "key", "value", "maybeQuote", "_parseVault", "options", "vaultPath", "_vaultPath", "result", "DotenvModule", "err", "keys", "_dotenvKey", "length", "decrypted", "i", "attrs", "_instructions", "error", "_log", "message", "_warn", "_debug", "dotenvKey", "uri", "environment", "environmentKey", "ciphertext", "possibleVaultPath", "filepath", "_resolveHome", "envPath", "_configVault", "parsed", "processEnv", "configDotenv", "dotenvPath", "encoding", "debug", "optionPaths", "lastError", "parsedAll", "e", "config", "decrypt", "encrypted", "keyStr", "nonce", "authTag", "aesgcm", "isRange", "invalidKeyLength", "decryptionFailed", "populate", "override", "consume_exports", "__export", "handler", "__toCommonJS", "import_nanoid", "ENV", "STAGE", "TABLES", "BUCKETS", "LIMITS", "ERROR_CODES", "HTTP_STATUS", "CONTENT_TYPES", "AppError", "code", "message", "statusCode", "details", "Errors", "ERROR_CODES", "HTTP_STATUS", "resource", "id", "topicId", "name", "messageId", "size", "maxSize", "groupId", "errorHandler", "err", "appError", "generateId", "prefix", "length", "id", "generateMessageId", "generateId", "generatePayloadKey", "topicId", "messageId", "timestamp", "validateMessageSize", "payload", "stringPayload", "size", "LIMITS", "Errors", "validateMetadata", "metadata", "keys", "key", "value", "formatResponse", "data", "formatApiResponse", "statusCode", "determineContentType", "contentType", "CONTENT_TYPES", "calculateExpirationTimestamp", "createdAt", "retentionPeriodHours", "getPathParameter", "pathParameters", "paramName", "Errors", "getQueryParameter", "queryStringParameters", "defaultValue", "parseIntParameter", "value", "min", "max", "parsed", "import_aws_sdk", "dotenv", "options", "dynamoClient", "import_aws_sdk", "dotenv", "options", "s3Client", "dotenv", "LOG_LEVEL_MAP", "logLevel", "logFormat", "currentLogLevel", "formatLogMessage", "level", "message", "data", "timestamp", "requestId", "logObject", "logMessage", "Logger", "logger", "logger_default", "storeMessage", "message", "payload", "logger", "s3Client", "BUCKETS", "dynamoClient", "TABLES", "error", "getMessageById", "messageId", "result", "Errors", "getMessages", "topicId", "fromSequence", "limit", "getMessagePayload", "payloadKey", "deleteMessage", "getNextSequenceNumber", "findExpiredMessages", "batchSize", "now", "message_repository_default", "createTopic", "topic", "logger", "dynamoClient", "TABLES", "error", "Errors", "getTopic", "topicId", "result", "getTopicByName", "name", "listTopics", "deleteTopic", "incrementMessageCount", "timestamp", "updateTopic", "updates", "updateExpressions", "expressionAttributeNames", "expressionAttributeValues", "key", "value", "topic_repository_default", "createConsumerGroup", "consumerGroup", "logger", "dynamoClient", "TABLES", "error", "Errors", "getConsumerGroup", "groupId", "topicId", "result", "getConsumerGroupByName", "name", "listConsumerGroups", "deleteConsumerGroup", "updateConsumerGroupTimestamp", "timestamp", "getConsumerOffset", "updateConsumerOffset", "offset", "consumer_repository_default", "publishMessage", "topicId", "request", "logger_default", "Errors", "validateMessageSize", "validateMetadata", "topic", "topic_repository_default", "sequenceNumber", "message_repository_default", "contentType", "determineContentType", "messageId", "generateMessageId", "payloadKey", "generatePayloadKey", "payload", "size", "timestamp", "expiresAt", "calculateExpirationTimestamp", "message", "consumeMessages", "maxMessages", "LIMITS", "waitTimeSeconds", "consumer_repository_default", "fromSequence", "offset", "messages", "endTime", "resolve", "messagesWithPayloads", "lastMessage", "getMessageById", "cleanupExpiredMessages", "batchSize", "expiredMessages", "deletedCount", "error", "message_service_default", "handler", "event", "logger_default", "topicId", "getPathParameter", "queryStringParameters", "consumerGroupId", "getQueryParameter", "maxMessages", "LIMITS", "waitTimeSeconds", "parseIntParameter", "request", "result", "message_service_default", "formatApiResponse", "error", "errorHandler"]
}
