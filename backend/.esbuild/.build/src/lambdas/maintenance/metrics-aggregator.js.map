{
  "version": 3,
  "sources": ["../../../../../src/common/constants.ts", "../../../../../src/common/config.ts", "../../../../../src/lambdas/maintenance/metrics-aggregator.ts", "../../../../../src/data/clients/dynamo-client.ts", "../../../../../src/data/repositories/metric-repository.ts", "../../../../../src/common/logger.ts", "../../../../../src/common/errors.ts", "../../../../../src/data/repositories/topic-repository.ts", "../../../../../src/services/metric-service.ts"],
  "sourcesContent": ["// Environment names\nexport const ENV = {\n    DEV: 'dev',\n    STAGING: 'staging',\n    PROD: 'prod',\n  };\n  \n  // Current environment\n  export const STAGE = process.env.STAGE || ENV.DEV;\n  \n  // DynamoDB table names\n  export const TABLES = {\n    TOPICS: process.env.TOPICS_TABLE || `MicroQueue-Topics-${STAGE}`,\n    MESSAGES: process.env.MESSAGES_TABLE || `MicroQueue-Messages-${STAGE}`,\n    CONSUMER_GROUPS: process.env.CONSUMER_GROUPS_TABLE || `MicroQueue-ConsumerGroups-${STAGE}`,\n    OFFSETS: process.env.OFFSETS_TABLE || `MicroQueue-Offsets-${STAGE}`,\n  };\n  \n  // S3 bucket names\n  export const BUCKETS = {\n    MESSAGES: process.env.MESSAGES_BUCKET || `microqueue-messages-${STAGE}`,\n    ARCHIVE: process.env.ARCHIVE_BUCKET || `microqueue-archive-${STAGE}`,\n  };\n  \n  // System limits\n  export const LIMITS = {\n    MAX_TOPIC_NAME_LENGTH: 100,\n    MAX_DESCRIPTION_LENGTH: 500,\n    MAX_MESSAGE_SIZE_BYTES: 256 * 1024, // 256KB\n    MAX_METADATA_KEYS: 10,\n    MAX_METADATA_KEY_LENGTH: 128,\n    MAX_METADATA_VALUE_LENGTH: 256,\n    MAX_RETENTION_HOURS: 7 * 24, // 1 week\n    DEFAULT_RETENTION_HOURS: 24, // 1 day\n    MAX_MESSAGES_PER_CONSUME: 100,\n    DEFAULT_MESSAGES_PER_CONSUME: 10,\n    MAX_WAIT_TIME_SECONDS: 20,\n    DEFAULT_WAIT_TIME_SECONDS: 0,\n  };\n  \n  // Error codes\n  export const ERROR_CODES = {\n    // General errors\n    INTERNAL_ERROR: 'INTERNAL_ERROR',\n    VALIDATION_ERROR: 'VALIDATION_ERROR',\n    RESOURCE_NOT_FOUND: 'RESOURCE_NOT_FOUND',\n    \n    // Topic errors\n    TOPIC_NOT_FOUND: 'TOPIC_NOT_FOUND',\n    TOPIC_ALREADY_EXISTS: 'TOPIC_ALREADY_EXISTS',\n    \n    // Message errors\n    MESSAGE_NOT_FOUND: 'MESSAGE_NOT_FOUND',\n    MESSAGE_TOO_LARGE: 'MESSAGE_TOO_LARGE',\n    INVALID_MESSAGE_FORMAT: 'INVALID_MESSAGE_FORMAT',\n    \n    // Consumer errors\n    CONSUMER_GROUP_NOT_FOUND: 'CONSUMER_GROUP_NOT_FOUND',\n    CONSUMER_GROUP_ALREADY_EXISTS: 'CONSUMER_GROUP_ALREADY_EXISTS',\n    \n    // System errors\n    RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',\n    SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',\n  };\n  \n  // HTTP Status codes\n  export const HTTP_STATUS = {\n    OK: 200,\n    CREATED: 201,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    CONFLICT: 409,\n    PAYLOAD_TOO_LARGE: 413,\n    UNPROCESSABLE_ENTITY: 422,\n    TOO_MANY_REQUESTS: 429,\n    INTERNAL_SERVER_ERROR: 500,\n    SERVICE_UNAVAILABLE: 503,\n  };\n  \n  // Content types\n  export const CONTENT_TYPES = {\n    JSON: 'application/json',\n    TEXT: 'text/plain',\n    XML: 'application/xml',\n    BINARY: 'application/octet-stream',\n  };\n  \n  // Raft consensus algorithm constants\n  export const RAFT = {\n    HEARTBEAT_INTERVAL_MS: 100,\n    ELECTION_TIMEOUT_MIN_MS: 150,\n    ELECTION_TIMEOUT_MAX_MS: 300,\n    MAX_LOG_ENTRIES_PER_REQUEST: 100,\n  };", "import { STAGE, ENV, LIMITS } from './constants';\n\n// Base configuration\nconst baseConfig = {\n  // System info\n  serviceName: 'MicroQueue-Mini',\n  version: '1.0.0',\n  \n  \n  // DynamoDB settings\n  dynamodb: {\n    maxRetries: 3,\n    timeout: 5000, // ms\n  },\n  \n  // S3 settings\n  s3: {\n    maxRetries: 3,\n    timeout: 10000, // ms\n  },\n  \n  // API settings\n  api: {\n    corsOrigins: '*',\n    rateLimit: {\n      windowMs: 60 * 1000, // 1 minute\n      max: 100, // limit each IP to 100 requests per windowMs\n    },\n  },\n  \n  // Logging\n  logging: {\n    level: 'info',\n    format: 'json',\n  },\n  \n  // Topic settings\n  topics: {\n    maxTopicsPerAccount: 100,\n    defaultRetentionHours: LIMITS.DEFAULT_RETENTION_HOURS,\n  },\n  \n  // Message settings\n  messages: {\n    maxSizeBytes: LIMITS.MAX_MESSAGE_SIZE_BYTES,\n    batchSize: 25,\n  },\n  \n  // Consumer settings\n  consumers: {\n    defaultMaxMessages: LIMITS.DEFAULT_MESSAGES_PER_CONSUME,\n    defaultWaitTimeSeconds: LIMITS.DEFAULT_WAIT_TIME_SECONDS,\n  },\n};\n\n// Environment specific configurations\nconst envConfigs = {\n  [ENV.DEV]: {\n    logging: {\n      level: 'debug',\n    },\n    topics: {\n      maxTopicsPerAccount: 20,\n    },\n  },\n  [ENV.STAGING]: {\n    logging: {\n      level: 'debug',\n    },\n    topics: {\n      maxTopicsPerAccount: 50,\n    },\n  },\n  [ENV.PROD]: {\n    logging: {\n      level: 'info',\n    },\n    topics: {\n      maxTopicsPerAccount: 100,\n    },\n    api: {\n      rateLimit: {\n        windowMs: 60 * 1000, // 1 minute\n        max: 200, // limit each IP to 200 requests per windowMs\n      },\n    },\n  },\n};\n\n// Merge base config with environment specific config\nconst environmentConfig = envConfigs[STAGE] || envConfigs[ENV.DEV];\n\n// Export the final configuration\nexport const config = {\n  ...baseConfig,\n  ...environmentConfig,\n  env: STAGE,\n};\n\nexport default config;", "import { ScheduledEvent, Context } from 'aws-lambda';\nimport metricService from '../../services/metric-service';\nimport logger from '../../common/logger';\n\nexport const handler = async (\n  event: ScheduledEvent,\n  context: Context\n): Promise<{ success: boolean }> => {\n  logger.info('Starting metrics aggregation', { event });\n\n  try {\n    await metricService.collectAndPublishMetrics();\n\n    logger.info('Metrics aggregation completed');\n\n    return {\n      success: true,\n    };\n  } catch (error) {\n    logger.error('Error during metrics aggregation', { error });\n    \n  \n    return {\n      success: false,\n    };\n  }\n};", "import { DynamoDB } from 'aws-sdk';\nimport { config } from '../../common/config';\n\n// Configure DynamoDB client\nconst options: DynamoDB.ClientConfiguration = {\n  maxRetries: config.dynamodb.maxRetries,\n  httpOptions: {\n    timeout: config.dynamodb.timeout,\n  },\n};\n\n// Use local endpoint for development if provided\nif (process.env.DYNAMODB_ENDPOINT) {\n  options.endpoint = process.env.DYNAMODB_ENDPOINT;\n}\n\n// Create DynamoDB document client instance\nexport const dynamoClient = new DynamoDB.DocumentClient(options);\n\nexport default dynamoClient;", "import { dynamoClient } from '../clients/dynamo-client';\nimport { TABLES } from '../../common/constants';\nimport { TopicMetrics, SystemMetrics } from '../../common/types';\nimport { logger } from '../../common/logger';\nimport { Errors } from '../../common/errors';\nimport AWS from 'aws-sdk';\n\n// Initialize CloudWatch client\nconst cloudWatch = new AWS.CloudWatch();\n\n\nexport const calculateTopicMetrics = async (topicId: string): Promise<TopicMetrics> => {\n  logger.debug('Calculating topic metrics', { topicId });\n\n  try {\n    // Get the topic\n    const topicResult = await dynamoClient.get({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n    }).promise();\n\n    if (!topicResult.Item) {\n      throw Errors.topicNotFound(topicId);\n    }\n\n    const topic = topicResult.Item;\n\n    // Get the most recent messages for rate calculation (last hour)\n    const oneHourAgo = Date.now() - 60 * 60 * 1000;\n    \n    // Just count the messages from the last hour\n    const recentMessagesResult = await dynamoClient.query({\n      TableName: TABLES.MESSAGES,\n      KeyConditionExpression: 'topicId = :topicId AND sequenceNumber > :seq',\n      FilterExpression: '#ts >= :ts',\n      ExpressionAttributeNames: {\n        '#ts': 'timestamp',\n      },\n      ExpressionAttributeValues: {\n        ':topicId': topicId,\n        ':seq': 0,\n        ':ts': oneHourAgo,\n      },\n      Select: 'COUNT',\n    }).promise();\n\n    const recentMessagesCount = recentMessagesResult.Count || 0;\n    const publishRate = recentMessagesCount / 60; // messages per minute\n\n    // Get the size statistics for messages\n    const messageSizesResult = await dynamoClient.query({\n      TableName: TABLES.MESSAGES,\n      KeyConditionExpression: 'topicId = :topicId',\n      ExpressionAttributeValues: {\n        ':topicId': topicId,\n      },\n      Limit: 100, // Just sample the most recent 100 messages\n      ScanIndexForward: false, // Descending order to get the most recent\n      ProjectionExpression: 'size',\n    }).promise();\n\n    const messageSizes = (messageSizesResult.Items || []).map((item) => item.size || 0);\n    const totalSize = messageSizes.reduce((sum, size) => sum + size, 0);\n    const averageMessageSize = messageSizes.length > 0\n      ? Math.round(totalSize / messageSizes.length)\n      : 0;\n\n    // Get oldest and newest messages\n    const oldestMessageResult = await dynamoClient.query({\n      TableName: TABLES.MESSAGES,\n      KeyConditionExpression: 'topicId = :topicId',\n      ExpressionAttributeValues: {\n        ':topicId': topicId,\n      },\n      Limit: 1,\n      ScanIndexForward: true, // Ascending order to get the oldest\n      ProjectionExpression: 'timestamp',\n    }).promise();\n\n    const newestMessageResult = await dynamoClient.query({\n      TableName: TABLES.MESSAGES,\n      KeyConditionExpression: 'topicId = :topicId',\n      ExpressionAttributeValues: {\n        ':topicId': topicId,\n      },\n      Limit: 1,\n      ScanIndexForward: false, // Descending order to get the newest\n      ProjectionExpression: 'timestamp',\n    }).promise();\n\n    const oldestMessage = oldestMessageResult.Items && oldestMessageResult.Items.length > 0\n      ? oldestMessageResult.Items[0].timestamp\n      : 0;\n\n    const newestMessage = newestMessageResult.Items && newestMessageResult.Items.length > 0\n      ? newestMessageResult.Items[0].timestamp\n      : 0;\n\n    // Get consumer groups to calculate consume rate\n    const consumerGroupsResult = await dynamoClient.query({\n      TableName: TABLES.CONSUMER_GROUPS,\n      KeyConditionExpression: 'topicId = :topicId',\n      ExpressionAttributeValues: {\n        ':topicId': topicId,\n      },\n    }).promise();\n\n    const consumerGroups = consumerGroupsResult.Items || [];\n    \n    // Calculate average consume rate from the last hour of activity\n    let totalConsumeRate = 0;\n    for (const group of consumerGroups) {\n      const groupId = group.groupId;\n      \n      // Get offset\n      const offsetResult = await dynamoClient.get({\n        TableName: TABLES.OFFSETS,\n        Key: { groupId, topicId },\n      }).promise();\n      \n      if (offsetResult.Item) {\n        const lastConsumedTimestamp = offsetResult.Item.lastConsumedTimestamp || 0;\n        const lastSequenceNumber = offsetResult.Item.lastSequenceNumber || 0;\n        \n        // If consumed in the last hour, estimate rate\n        if (lastConsumedTimestamp > oneHourAgo) {\n          // Roughly estimate consume rate based on sequence number and timestamp\n          const consumedMessages = lastSequenceNumber;\n          const hoursSinceStart = (lastConsumedTimestamp - topic.createdAt) / (60 * 60 * 1000);\n          \n          if (hoursSinceStart > 0) {\n            totalConsumeRate += consumedMessages / (hoursSinceStart * 60); // per minute\n          }\n        }\n      }\n    }\n    \n    const consumeRate = consumerGroups.length > 0\n      ? totalConsumeRate / consumerGroups.length\n      : 0;\n\n    return {\n      topicId,\n      name: topic.name,\n      messageCount: topic.messageCount || 0,\n      publishRate,\n      consumeRate,\n      averageMessageSize,\n      oldestMessage,\n      newestMessage,\n    };\n  } catch (error) {\n    logger.error('Error calculating topic metrics', { error, topicId });\n    throw error;\n  }\n};\n\n\nexport const calculateSystemMetrics = async (): Promise<SystemMetrics> => {\n  logger.debug('Calculating system metrics');\n\n  try {\n    // Get counts from DynamoDB\n    const [topicsResult, messagesResult, consumerGroupsResult] = await Promise.all([\n      dynamoClient.scan({\n        TableName: TABLES.TOPICS,\n        Select: 'COUNT',\n      }).promise(),\n      \n      dynamoClient.scan({\n        TableName: TABLES.MESSAGES,\n        Select: 'COUNT',\n      }).promise(),\n      \n      dynamoClient.scan({\n        TableName: TABLES.CONSUMER_GROUPS,\n        Select: 'COUNT',\n      }).promise(),\n    ]);\n\n    const totalTopics = topicsResult.Count || 0;\n    const totalMessages = messagesResult.Count || 0;\n    const totalConsumerGroups = consumerGroupsResult.Count || 0;\n\n    // Calculate average publish rate (last hour)\n    const oneHourAgo = Date.now() - 60 * 60 * 1000;\n    \n    const recentMessagesResult = await dynamoClient.scan({\n      TableName: TABLES.MESSAGES,\n      FilterExpression: '#ts >= :ts',\n      ExpressionAttributeNames: {\n        '#ts': 'timestamp',\n      },\n      ExpressionAttributeValues: {\n        ':ts': oneHourAgo,\n      },\n      Select: 'COUNT',\n    }).promise();\n\n    const recentMessagesCount = recentMessagesResult.Count || 0;\n    const averagePublishRate = recentMessagesCount / 60; // messages per minute\n\n    // Estimate average consume rate\n    let totalConsumeCount = 0;\n    \n    // Sample a subset of consumer groups for performance\n    const consumerSampleResult = await dynamoClient.scan({\n      TableName: TABLES.OFFSETS,\n      Limit: 100, // Sample at most 100 consumer groups\n    }).promise();\n    \n    const consumerSample = consumerSampleResult.Items || [];\n    \n    for (const offset of consumerSample) {\n      if (offset.lastConsumedTimestamp > oneHourAgo) {\n        totalConsumeCount += offset.lastSequenceNumber || 0;\n      }\n    }\n    \n    const averageConsumeRate = consumerSample.length > 0\n      ? (totalConsumeCount / consumerSample.length) / 60\n      : 0;\n\n    // Get S3 storage metrics from CloudWatch (this would work in a real AWS environment)\n    // For a hackathon, we'll estimate based on DynamoDB data\n    let storageUsed = 0;\n    \n    // Get sample of message sizes\n    const messageSizeSampleResult = await dynamoClient.scan({\n      TableName: TABLES.MESSAGES,\n      Limit: 100,\n      ProjectionExpression: 'size',\n    }).promise();\n    \n    const messageSizes = (messageSizeSampleResult.Items || []).map((item) => item.size || 0);\n    \n    if (messageSizes.length > 0) {\n      const avgSize = messageSizes.reduce((sum, size) => sum + size, 0) / messageSizes.length;\n      storageUsed = avgSize * totalMessages;\n    }\n\n    return {\n      totalTopics,\n      totalMessages,\n      totalConsumerGroups,\n      averagePublishRate,\n      averageConsumeRate,\n      storageUsed,\n    };\n  } catch (error) {\n    logger.error('Error calculating system metrics', { error });\n    throw error;\n  }\n};\n\n\nexport const pushMetricsToCloudWatch = async (\n  topicMetrics: TopicMetrics[] = [],\n  systemMetrics?: SystemMetrics\n): Promise<void> => {\n  try {\n    const timestamp = new Date();\n    const metricData: AWS.CloudWatch.MetricData = [];\n\n    // Add topic metrics\n    for (const topic of topicMetrics) {\n      metricData.push(\n        {\n          MetricName: 'MessageCount',\n          Dimensions: [\n            { Name: 'TopicId', Value: topic.topicId },\n            { Name: 'TopicName', Value: topic.name },\n          ],\n          Value: topic.messageCount,\n          Timestamp: timestamp,\n          Unit: 'Count',\n        },\n        {\n          MetricName: 'PublishRate',\n          Dimensions: [\n            { Name: 'TopicId', Value: topic.topicId },\n            { Name: 'TopicName', Value: topic.name },\n          ],\n          Value: topic.publishRate,\n          Timestamp: timestamp,\n          Unit: 'Count/Minute',\n        },\n        {\n          MetricName: 'ConsumeRate',\n          Dimensions: [\n            { Name: 'TopicId', Value: topic.topicId },\n            { Name: 'TopicName', Value: topic.name },\n          ],\n          Value: topic.consumeRate,\n          Timestamp: timestamp,\n          Unit: 'Count/Minute',\n        },\n        {\n          MetricName: 'AverageMessageSize',\n          Dimensions: [\n            { Name: 'TopicId', Value: topic.topicId },\n            { Name: 'TopicName', Value: topic.name },\n          ],\n          Value: topic.averageMessageSize,\n          Timestamp: timestamp,\n          Unit: 'Bytes',\n        }\n      );\n    }\n\n    // Add system metrics\n    if (systemMetrics) {\n      metricData.push(\n        {\n          MetricName: 'TotalTopics',\n          Value: systemMetrics.totalTopics,\n          Timestamp: timestamp,\n          Unit: 'Count',\n        },\n        {\n          MetricName: 'TotalMessages',\n          Value: systemMetrics.totalMessages,\n          Timestamp: timestamp,\n          Unit: 'Count',\n        },\n        {\n          MetricName: 'TotalConsumerGroups',\n          Value: systemMetrics.totalConsumerGroups,\n          Timestamp: timestamp,\n          Unit: 'Count',\n        },\n        {\n          MetricName: 'AveragePublishRate',\n          Value: systemMetrics.averagePublishRate,\n          Timestamp: timestamp,\n          Unit: 'Count/Minute',\n        },\n        {\n          MetricName: 'AverageConsumeRate',\n          Value: systemMetrics.averageConsumeRate,\n          Timestamp: timestamp,\n          Unit: 'Count/Minute',\n        },\n        {\n          MetricName: 'StorageUsed',\n          Value: systemMetrics.storageUsed,\n          Timestamp: timestamp,\n          Unit: 'Bytes',\n        }\n      );\n    }\n\n    // Push metrics to CloudWatch in batches of 20 (CloudWatch API limit)\n    const batchSize = 20;\n    for (let i = 0; i < metricData.length; i += batchSize) {\n      const batch = metricData.slice(i, i + batchSize);\n      \n      await cloudWatch.putMetricData({\n        Namespace: 'MicroQueue',\n        MetricData: batch,\n      }).promise();\n    }\n  } catch (error) {\n    logger.error('Error pushing metrics to CloudWatch', { error });\n   \n  }\n};\n\nexport default {\n  calculateTopicMetrics,\n  calculateSystemMetrics,\n  pushMetricsToCloudWatch,\n};", "const config: Config = require('./config');\n\ninterface LoggingConfig {\n  level: string;\n  format: string;\n}\n\ninterface Config {\n  logging: LoggingConfig;\n  serviceName: string;\n  version: string;\n  env: string;\n}\n\n// Log levels\nexport enum LogLevel {\n  ERROR = 0,\n  WARN = 1,\n  INFO = 2,\n  DEBUG = 3,\n}\n\n\n// Map string log levels to enum\nconst LOG_LEVEL_MAP: Record<string, LogLevel> = {\n  error: LogLevel.ERROR,\n  warn: LogLevel.WARN,\n  info: LogLevel.INFO,\n  debug: LogLevel.DEBUG,\n};\n\n// Get current log level from config\nconst currentLogLevel = LOG_LEVEL_MAP[config.logging.level] || LogLevel.INFO;\n\n\nconst formatLogMessage = (level: string, message: string, data?: any): string => {\n  const timestamp = new Date().toISOString();\n  const requestId = process.env.AWS_REQUEST_ID || '-';\n  \n  if (config.logging.format === 'json') {\n    const logObject = {\n      timestamp,\n      level,\n      message,\n      requestId,\n      service: config.serviceName,\n      version: config.version,\n      env: config.env,\n      ...(data ? { data } : {}),\n    };\n    \n    return JSON.stringify(logObject);\n  }\n  \n  // Default to plain text format\n  let logMessage = `[${timestamp}] [${level.toUpperCase()}] [${requestId}] ${message}`;\n  \n  if (data) {\n    logMessage += ` ${JSON.stringify(data)}`;\n  }\n  \n  return logMessage;\n};\n\nclass Logger {\n\n  error(message: string, data?: any): void {\n    if (currentLogLevel >= LogLevel.ERROR) {\n      console.error(formatLogMessage('error', message, data));\n    }\n  }\n  \n  \n  warn(message: string, data?: any): void {\n    if (currentLogLevel >= LogLevel.WARN) {\n      console.warn(formatLogMessage('warn', message, data));\n    }\n  }\n  \n\n  info(message: string, data?: any): void {\n    if (currentLogLevel >= LogLevel.INFO) {\n      console.info(formatLogMessage('info', message, data));\n    }\n  }\n\n  debug(message: string, data?: any): void {\n    if (currentLogLevel >= LogLevel.DEBUG) {\n      console.debug(formatLogMessage('debug', message, data));\n    }\n  }\n}\n\n// Export singleton logger instance\nexport const logger = new Logger();\n\nexport default logger;", "import { MicroQueueError } from './types';\nimport { ERROR_CODES, HTTP_STATUS } from './constants';\n\nexport class AppError extends Error implements MicroQueueError {\n  code: string;\n  statusCode: number;\n  details?: any;\n\n  constructor(code: string, message: string, statusCode: number, details?: any) {\n    super(message);\n    this.code = code;\n    this.statusCode = statusCode;\n    this.details = details;\n    this.name = 'AppError';\n    \n    // Capturing the stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AppError);\n    }\n  }\n\n  \n  toResponse() {\n    return {\n      success: false,\n      error: {\n        code: this.code,\n        message: this.message,\n        details: this.details,\n      },\n    };\n  }\n}\n\nexport const Errors = {\n  // General errors\n  internalError: (message = 'An internal server error occurred', details?: any) => \n    new AppError(ERROR_CODES.INTERNAL_ERROR, message, HTTP_STATUS.INTERNAL_SERVER_ERROR, details),\n  \n  validationError: (message = 'Validation error', details?: any) => \n    new AppError(ERROR_CODES.VALIDATION_ERROR, message, HTTP_STATUS.BAD_REQUEST, details),\n  \n  resourceNotFound: (resource: string, id: string) => \n    new AppError(ERROR_CODES.RESOURCE_NOT_FOUND, `${resource} with id '${id}' not found`, HTTP_STATUS.NOT_FOUND),\n  \n  // Topic errors\n  topicNotFound: (topicId: string) => \n    new AppError(ERROR_CODES.TOPIC_NOT_FOUND, `Topic '${topicId}' not found`, HTTP_STATUS.NOT_FOUND),\n  \n  topicAlreadyExists: (name: string) => \n    new AppError(ERROR_CODES.TOPIC_ALREADY_EXISTS, `Topic with name '${name}' already exists`, HTTP_STATUS.CONFLICT),\n  \n  // Message errors\n  messageNotFound: (messageId: string) => \n    new AppError(ERROR_CODES.MESSAGE_NOT_FOUND, `Message '${messageId}' not found`, HTTP_STATUS.NOT_FOUND),\n  \n  messageTooLarge: (size: number, maxSize: number) => \n    new AppError(\n      ERROR_CODES.MESSAGE_TOO_LARGE, \n      `Message size (${size} bytes) exceeds maximum allowed size (${maxSize} bytes)`, \n      HTTP_STATUS.PAYLOAD_TOO_LARGE\n    ),\n  \n  // Consumer errors\n  consumerGroupNotFound: (groupId: string) => \n    new AppError(ERROR_CODES.CONSUMER_GROUP_NOT_FOUND, `Consumer group '${groupId}' not found`, HTTP_STATUS.NOT_FOUND),\n  \n  consumerGroupAlreadyExists: (name: string, topicId: string) => \n    new AppError(\n      ERROR_CODES.CONSUMER_GROUP_ALREADY_EXISTS, \n      `Consumer group with name '${name}' already exists for topic '${topicId}'`, \n      HTTP_STATUS.CONFLICT\n    ),\n  \n  // System errors\n  rateLimitExceeded: () => \n    new AppError(ERROR_CODES.RATE_LIMIT_EXCEEDED, 'Rate limit exceeded', HTTP_STATUS.TOO_MANY_REQUESTS),\n  \n  serviceUnavailable: (message = 'Service temporarily unavailable') => \n    new AppError(ERROR_CODES.SERVICE_UNAVAILABLE, message, HTTP_STATUS.SERVICE_UNAVAILABLE),\n};\n\n\nexport const errorHandler = (err: any) => {\n  console.error('Error:', err);\n  \n  // If it's already our AppError, return it\n  if (err instanceof AppError) {\n    return {\n      statusCode: err.statusCode,\n      body: JSON.stringify(err.toResponse()),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n  }\n  \n  // Handle specific AWS SDK errors\n  if (err.code === 'ConditionalCheckFailedException') {\n    const appError = Errors.resourceNotFound('Resource', 'unknown');\n    return {\n      statusCode: appError.statusCode,\n      body: JSON.stringify(appError.toResponse()),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n  }\n  \n  // Handle other known AWS errors\n  if (err.code === 'ThrottlingException') {\n    const appError = Errors.rateLimitExceeded();\n    return {\n      statusCode: appError.statusCode,\n      body: JSON.stringify(appError.toResponse()),\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n  }\n  \n  // Default to internal server error\n  const appError = Errors.internalError(err.message || 'An unexpected error occurred');\n  return {\n    statusCode: appError.statusCode,\n    body: JSON.stringify(appError.toResponse()),\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  };\n};", "\nimport { dynamoClient } from '../clients/dynamo-client';\nimport { TABLES } from '../../common/constants';\nimport { Topic } from '../../common/types';\nimport { logger } from '../../common/logger';\nimport { Errors } from '../../common/errors';\n\n\nexport const createTopic = async (topic: Topic): Promise<Topic> => {\n  logger.debug('Creating topic', { topicId: topic.topicId });\n  \n  try {\n    await dynamoClient.put({\n      TableName: TABLES.TOPICS,\n      Item: topic,\n      ConditionExpression: 'attribute_not_exists(topicId)',\n    }).promise();\n    \n    return topic;\n  } catch (error) {\n    logger.error('Error creating topic', { error, topic });\n    \n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.topicAlreadyExists(topic.name);\n    }\n    \n    throw error;\n  }\n};\n\n\nexport const getTopic = async (topicId: string): Promise<Topic> => {\n  logger.debug('Getting topic', { topicId });\n  \n  try {\n    const result = await dynamoClient.get({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n    }).promise();\n    \n    if (!result.Item) {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    return result.Item as Topic;\n  } catch (error) {\n    logger.error('Error getting topic', { error, topicId });\n    \n    if ((error as any).code === 'ResourceNotFoundException') {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    throw error;\n  }\n};\n\nexport const getTopicByName = async (name: string): Promise<Topic | null> => {\n  logger.debug('Getting topic by name', { name });\n  \n  try {\n    const result = await dynamoClient.scan({\n      TableName: TABLES.TOPICS,\n      FilterExpression: '#name = :name',\n      ExpressionAttributeNames: {\n        '#name': 'name',\n      },\n      ExpressionAttributeValues: {\n        ':name': name,\n      },\n      Limit: 1,\n    }).promise();\n    \n    if (result.Items && result.Items.length > 0) {\n      return result.Items[0] as Topic;\n    }\n    \n    return null;\n  } catch (error) {\n    logger.error('Error getting topic by name', { error, name });\n    throw error;\n  }\n};\n\n\nexport const listTopics = async (): Promise<Topic[]> => {\n  logger.debug('Listing topics');\n  \n  try {\n    const result = await dynamoClient.scan({\n      TableName: TABLES.TOPICS,\n    }).promise();\n    \n    return (result.Items || []) as Topic[];\n  } catch (error) {\n    logger.error('Error listing topics', { error });\n    throw error;\n  }\n};\n\n\nexport const deleteTopic = async (topicId: string): Promise<void> => {\n  logger.debug('Deleting topic', { topicId });\n  \n  try {\n    await dynamoClient.delete({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n      ConditionExpression: 'attribute_exists(topicId)',\n    }).promise();\n  } catch (error) {\n    logger.error('Error deleting topic', { error, topicId });\n    \n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    throw error;\n  }\n};\n\n\nexport const incrementMessageCount = async (topicId: string, timestamp: number): Promise<void> => {\n  logger.debug('Incrementing topic message count', { topicId, timestamp });\n  \n  try {\n    await dynamoClient.update({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n      UpdateExpression: 'SET messageCount = messageCount + :inc, lastMessageTimestamp = :ts',\n      ExpressionAttributeValues: {\n        ':inc': 1,\n        ':ts': timestamp,\n      },\n      ConditionExpression: 'attribute_exists(topicId)',\n    }).promise();\n  } catch (error) {\n    logger.error('Error incrementing message count', { error, topicId });\n    \n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    throw error;\n  }\n};\n\n\nexport const updateTopic = async (\n  topicId: string,\n  updates: Partial<Omit<Topic, 'topicId' | 'createdAt'>>\n): Promise<Topic> => {\n  logger.debug('Updating topic', { topicId, updates });\n  \n  // Build update expression\n  const updateExpressions: string[] = [];\n  const expressionAttributeNames: Record<string, string> = {};\n  const expressionAttributeValues: Record<string, any> = {};\n  \n  Object.entries(updates).forEach(([key, value]) => {\n    if (value !== undefined) {\n      updateExpressions.push(`#${key} = :${key}`);\n      expressionAttributeNames[`#${key}`] = key;\n      expressionAttributeValues[`:${key}`] = value;\n    }\n  });\n  \n  if (updateExpressions.length === 0) {\n    return getTopic(topicId);\n  }\n  \n  try {\n    await dynamoClient.update({\n      TableName: TABLES.TOPICS,\n      Key: { topicId },\n      UpdateExpression: `SET ${updateExpressions.join(', ')}`,\n      ExpressionAttributeNames: expressionAttributeNames,\n      ExpressionAttributeValues: expressionAttributeValues,\n      ConditionExpression: 'attribute_exists(topicId)',\n      ReturnValues: 'NONE',\n    }).promise();\n    \n    return getTopic(topicId);\n  } catch (error) {\n    logger.error('Error updating topic', { error, topicId });\n    \n    if ((error as any).code === 'ConditionalCheckFailedException') {\n      throw Errors.topicNotFound(topicId);\n    }\n    \n    throw error;\n  }\n};\n\nexport default {\n  createTopic,\n  getTopic,\n  getTopicByName,\n  listTopics,\n  deleteTopic,\n  incrementMessageCount,\n  updateTopic,\n};", "import { \n    TopicMetrics,\n    SystemMetrics,\n  } from '../common/types';\n  import metricRepository from '../data/repositories/metric-repository';\n  import topicRepository from '../data/repositories/topic-repository';\n  import logger from '../common/logger';\n\n  export const getTopicMetrics = async (topicId: string): Promise<TopicMetrics> => {\n    logger.debug('Getting topic metrics', { topicId });\n    \n    // Verify the topic exists\n    await topicRepository.getTopic(topicId);\n    \n    return metricRepository.calculateTopicMetrics(topicId);\n  };\n  \n \n  export const getAllTopicMetrics = async (): Promise<TopicMetrics[]> => {\n    logger.debug('Getting all topic metrics');\n    \n    // Get all topics\n    const topics = await topicRepository.listTopics();\n    \n    // Calculate metrics for each topic\n    const metricsPromises = topics.map(topic => \n      metricRepository.calculateTopicMetrics(topic.topicId)\n    );\n    \n    return Promise.all(metricsPromises);\n  };\n  \n  export const getSystemMetrics = async (): Promise<SystemMetrics> => {\n    logger.debug('Getting system metrics');\n    return metricRepository.calculateSystemMetrics();\n  };\n  \n\n  export const collectAndPublishMetrics = async (): Promise<void> => {\n    logger.debug('Collecting and publishing metrics');\n    \n    try {\n      // Get system metrics\n      const systemMetrics = await getSystemMetrics();\n      \n      // Get topic metrics for a subset of topics (to avoid overloading)\n      const topics = await topicRepository.listTopics();\n      const topicSample = topics.slice(0, 10); // Limit to 10 topics\n      \n      const topicMetrics = await Promise.all(\n        topicSample.map(topic => metricRepository.calculateTopicMetrics(topic.topicId))\n      );\n      \n      // Publish metrics to CloudWatch\n      await metricRepository.pushMetricsToCloudWatch(topicMetrics, systemMetrics);\n      \n      logger.info('Metrics published successfully');\n    } catch (error) {\n      logger.error('Error collecting and publishing metrics', { error });\n      // Don't rethrow - this is a background job\n    }\n  };\n  \n  \n  export const getDashboardMetrics = async (): Promise<{\n    system: SystemMetrics;\n    topics: TopicMetrics[];\n  }> => {\n    logger.debug('Getting dashboard metrics');\n    \n    // Get system metrics\n    const systemMetrics = await getSystemMetrics();\n    \n    // Get all topics\n    const topics = await topicRepository.listTopics();\n    \n    // For large systems, limit the number of topics to avoid overloading\n    const limitedTopics = topics.slice(0, 20); // Limit to 20 topics\n    \n    // Calculate metrics for each topic\n    const topicMetrics = await Promise.all(\n      limitedTopics.map(topic => metricRepository.calculateTopicMetrics(topic.topicId))\n    );\n    \n    // Sort by message count descending\n    topicMetrics.sort((a, b) => b.messageCount - a.messageCount);\n    \n    return {\n      system: systemMetrics,\n      topics: topicMetrics,\n    };\n  };\n  \n  export default {\n    getTopicMetrics,\n    getAllTopicMetrics,\n    getSystemMetrics,\n    collectAndPublishMetrics,\n    getDashboardMetrics,\n  };"],
  "mappings": "wmBAAA,IACaA,EAOEC,EAGAC,EAQAC,GAMAC,EAgBAC,EAyBAC,EAlEfC,EAAAC,EAAA,kBACaR,EAAM,CACf,IAAK,MACL,QAAS,UACT,KAAM,MACR,EAGaC,EAAQ,QAAQ,IAAI,OAASD,EAAI,IAGjCE,EAAS,CACpB,OAAQ,QAAQ,IAAI,cAAgB,qBAAqBD,IACzD,SAAU,QAAQ,IAAI,gBAAkB,uBAAuBA,IAC/D,gBAAiB,QAAQ,IAAI,uBAAyB,6BAA6BA,IACnF,QAAS,QAAQ,IAAI,eAAiB,sBAAsBA,GAC9D,EAGaE,GAAU,CACrB,SAAU,QAAQ,IAAI,iBAAmB,uBAAuBF,IAChE,QAAS,QAAQ,IAAI,gBAAkB,sBAAsBA,GAC/D,EAGaG,EAAS,CACpB,sBAAuB,IACvB,uBAAwB,IACxB,uBAAwB,IAAM,KAC9B,kBAAmB,GACnB,wBAAyB,IACzB,0BAA2B,IAC3B,oBAAqB,EAAI,GACzB,wBAAyB,GACzB,yBAA0B,IAC1B,6BAA8B,GAC9B,sBAAuB,GACvB,0BAA2B,CAC7B,EAGaC,EAAc,CAEzB,eAAgB,iBAChB,iBAAkB,mBAClB,mBAAoB,qBAGpB,gBAAiB,kBACjB,qBAAsB,uBAGtB,kBAAmB,oBACnB,kBAAmB,oBACnB,uBAAwB,yBAGxB,yBAA0B,2BAC1B,8BAA+B,gCAG/B,oBAAqB,sBACrB,oBAAqB,qBACvB,EAGaC,EAAc,CACzB,GAAI,IACJ,QAAS,IACT,YAAa,IACb,aAAc,IACd,UAAW,IACX,UAAW,IACX,SAAU,IACV,kBAAmB,IACnB,qBAAsB,IACtB,kBAAmB,IACnB,sBAAuB,IACvB,oBAAqB,GACvB,IC/EF,IAAAG,EAAA,GAAAC,EAAAD,EAAA,YAAAE,EAAA,YAAAC,KAAA,IAGMC,GAqDAC,EAkCAC,GAGOJ,EAMNC,GAnGPI,EAAAC,EAAA,kBAAAC,IAGML,GAAa,CAEjB,YAAa,kBACb,QAAS,QAIT,SAAU,CACR,WAAY,EACZ,QAAS,GACX,EAGA,GAAI,CACF,WAAY,EACZ,QAAS,GACX,EAGA,IAAK,CACH,YAAa,IACb,UAAW,CACT,SAAU,GAAK,IACf,IAAK,GACP,CACF,EAGA,QAAS,CACP,MAAO,OACP,OAAQ,MACV,EAGA,OAAQ,CACN,oBAAqB,IACrB,sBAAuBM,EAAO,uBAChC,EAGA,SAAU,CACR,aAAcA,EAAO,uBACrB,UAAW,EACb,EAGA,UAAW,CACT,mBAAoBA,EAAO,6BAC3B,uBAAwBA,EAAO,yBACjC,CACF,EAGML,EAAa,CACjB,CAACM,EAAI,KAAM,CACT,QAAS,CACP,MAAO,OACT,EACA,OAAQ,CACN,oBAAqB,EACvB,CACF,EACA,CAACA,EAAI,SAAU,CACb,QAAS,CACP,MAAO,OACT,EACA,OAAQ,CACN,oBAAqB,EACvB,CACF,EACA,CAACA,EAAI,MAAO,CACV,QAAS,CACP,MAAO,MACT,EACA,OAAQ,CACN,oBAAqB,GACvB,EACA,IAAK,CACH,UAAW,CACT,SAAU,GAAK,IACf,IAAK,GACP,CACF,CACF,CACF,EAGML,GAAoBD,EAAWO,IAAUP,EAAWM,EAAI,KAGjDT,EAAS,CACpB,GAAGE,GACH,GAAGE,GACH,IAAKM,CACP,EAEOT,GAAQD,ICnGf,IAAAW,GAAA,GAAAC,EAAAD,GAAA,aAAAE,KAAA,eAAAC,EAAAH,ICAA,IAAAI,EAAyB,mBACzBC,IAGA,IAAMC,EAAwC,CAC5C,WAAYC,EAAO,SAAS,WAC5B,YAAa,CACX,QAASA,EAAO,SAAS,OAC3B,CACF,EAGI,QAAQ,IAAI,oBACdD,EAAQ,SAAW,QAAQ,IAAI,mBAI1B,IAAME,EAAe,IAAI,WAAS,eAAeF,CAAO,EChB/DG,ICDA,IAAMC,EAAiB,WAwBvB,IAAMC,GAA0C,CAC9C,MAAO,EACP,KAAM,EACN,KAAM,EACN,MAAO,CACT,EAGMC,EAAkBD,GAAcE,EAAO,QAAQ,QAAU,EAGzDC,EAAmB,CAACC,EAAeC,EAAiBC,IAAuB,CAC/E,IAAMC,EAAY,IAAI,KAAK,EAAE,YAAY,EACnCC,EAAY,QAAQ,IAAI,gBAAkB,IAEhD,GAAIN,EAAO,QAAQ,SAAW,OAAQ,CACpC,IAAMO,EAAY,CAChB,UAAAF,EACA,MAAAH,EACA,QAAAC,EACA,UAAAG,EACA,QAASN,EAAO,YAChB,QAASA,EAAO,QAChB,IAAKA,EAAO,IACZ,GAAII,EAAO,CAAE,KAAAA,CAAK,EAAI,CAAC,CACzB,EAEA,OAAO,KAAK,UAAUG,CAAS,CACjC,CAGA,IAAIC,EAAa,IAAIH,OAAeH,EAAM,YAAY,OAAOI,MAAcH,IAE3E,OAAIC,IACFI,GAAc,IAAI,KAAK,UAAUJ,CAAI,KAGhCI,CACT,EAEMC,EAAN,KAAa,CAEX,MAAMN,EAAiBC,EAAkB,CACnCL,GAAmB,GACrB,QAAQ,MAAME,EAAiB,QAASE,EAASC,CAAI,CAAC,CAE1D,CAGA,KAAKD,EAAiBC,EAAkB,CAClCL,GAAmB,GACrB,QAAQ,KAAKE,EAAiB,OAAQE,EAASC,CAAI,CAAC,CAExD,CAGA,KAAKD,EAAiBC,EAAkB,CAClCL,GAAmB,GACrB,QAAQ,KAAKE,EAAiB,OAAQE,EAASC,CAAI,CAAC,CAExD,CAEA,MAAMD,EAAiBC,EAAkB,CACnCL,GAAmB,GACrB,QAAQ,MAAME,EAAiB,QAASE,EAASC,CAAI,CAAC,CAE1D,CACF,EAGaM,EAAS,IAAID,EAEnBE,EAAQD,EC/FfE,IAEO,IAAMC,EAAN,cAAuB,KAAiC,CAK7D,YAAYC,EAAcC,EAAiBC,EAAoBC,EAAe,CAC5E,MAAMF,CAAO,EACb,KAAK,KAAOD,EACZ,KAAK,WAAaE,EAClB,KAAK,QAAUC,EACf,KAAK,KAAO,WAGR,MAAM,mBACR,MAAM,kBAAkB,KAAMJ,CAAQ,CAE1C,CAGA,YAAa,CACX,MAAO,CACL,QAAS,GACT,MAAO,CACL,KAAM,KAAK,KACX,QAAS,KAAK,QACd,QAAS,KAAK,OAChB,CACF,CACF,CACF,EAEaK,EAAS,CAEpB,cAAe,CAACH,EAAU,oCAAqCE,IAC7D,IAAIJ,EAASM,EAAY,eAAgBJ,EAASK,EAAY,sBAAuBH,CAAO,EAE9F,gBAAiB,CAACF,EAAU,mBAAoBE,IAC9C,IAAIJ,EAASM,EAAY,iBAAkBJ,EAASK,EAAY,YAAaH,CAAO,EAEtF,iBAAkB,CAACI,EAAkBC,IACnC,IAAIT,EAASM,EAAY,mBAAoB,GAAGE,cAAqBC,eAAiBF,EAAY,SAAS,EAG7G,cAAgBG,GACd,IAAIV,EAASM,EAAY,gBAAiB,UAAUI,eAAsBH,EAAY,SAAS,EAEjG,mBAAqBI,GACnB,IAAIX,EAASM,EAAY,qBAAsB,oBAAoBK,oBAAwBJ,EAAY,QAAQ,EAGjH,gBAAkBK,GAChB,IAAIZ,EAASM,EAAY,kBAAmB,YAAYM,eAAwBL,EAAY,SAAS,EAEvG,gBAAiB,CAACM,EAAcC,IAC9B,IAAId,EACFM,EAAY,kBACZ,iBAAiBO,0CAA6CC,WAC9DP,EAAY,iBACd,EAGF,sBAAwBQ,GACtB,IAAIf,EAASM,EAAY,yBAA0B,mBAAmBS,eAAsBR,EAAY,SAAS,EAEnH,2BAA4B,CAACI,EAAcD,IACzC,IAAIV,EACFM,EAAY,8BACZ,6BAA6BK,gCAAmCD,KAChEH,EAAY,QACd,EAGF,kBAAmB,IACjB,IAAIP,EAASM,EAAY,oBAAqB,sBAAuBC,EAAY,iBAAiB,EAEpG,mBAAoB,CAACL,EAAU,oCAC7B,IAAIF,EAASM,EAAY,oBAAqBJ,EAASK,EAAY,mBAAmB,CAC1F,EF3EA,IAAAS,EAAgB,uBAGVC,GAAa,IAAI,EAAAC,QAAI,WAGdC,GAAwB,MAAOC,GAA2C,CACrFC,EAAO,MAAM,4BAA6B,CAAE,QAAAD,CAAQ,CAAC,EAErD,GAAI,CAEF,IAAME,EAAc,MAAMC,EAAa,IAAI,CACzC,UAAWC,EAAO,OAClB,IAAK,CAAE,QAAAJ,CAAQ,CACjB,CAAC,EAAE,QAAQ,EAEX,GAAI,CAACE,EAAY,KACf,MAAMG,EAAO,cAAcL,CAAO,EAGpC,IAAMM,EAAQJ,EAAY,KAGpBK,EAAa,KAAK,IAAI,EAAI,GAAK,GAAK,IAmBpCC,IAhBuB,MAAML,EAAa,MAAM,CACpD,UAAWC,EAAO,SAClB,uBAAwB,+CACxB,iBAAkB,aAClB,yBAA0B,CACxB,MAAO,WACT,EACA,0BAA2B,CACzB,WAAYJ,EACZ,OAAQ,EACR,MAAOO,CACT,EACA,OAAQ,OACV,CAAC,EAAE,QAAQ,GAEsC,OAAS,GAChB,GAcpCE,IAXqB,MAAMN,EAAa,MAAM,CAClD,UAAWC,EAAO,SAClB,uBAAwB,qBACxB,0BAA2B,CACzB,WAAYJ,CACd,EACA,MAAO,IACP,iBAAkB,GAClB,qBAAsB,MACxB,CAAC,EAAE,QAAQ,GAE8B,OAAS,CAAC,GAAG,IAAKU,GAASA,EAAK,MAAQ,CAAC,EAC5EC,EAAYF,EAAa,OAAO,CAACG,EAAKC,IAASD,EAAMC,EAAM,CAAC,EAC5DC,EAAqBL,EAAa,OAAS,EAC7C,KAAK,MAAME,EAAYF,EAAa,MAAM,EAC1C,EAGEM,EAAsB,MAAMZ,EAAa,MAAM,CACnD,UAAWC,EAAO,SAClB,uBAAwB,qBACxB,0BAA2B,CACzB,WAAYJ,CACd,EACA,MAAO,EACP,iBAAkB,GAClB,qBAAsB,WACxB,CAAC,EAAE,QAAQ,EAELgB,EAAsB,MAAMb,EAAa,MAAM,CACnD,UAAWC,EAAO,SAClB,uBAAwB,qBACxB,0BAA2B,CACzB,WAAYJ,CACd,EACA,MAAO,EACP,iBAAkB,GAClB,qBAAsB,WACxB,CAAC,EAAE,QAAQ,EAELiB,EAAgBF,EAAoB,OAASA,EAAoB,MAAM,OAAS,EAClFA,EAAoB,MAAM,GAAG,UAC7B,EAEEG,EAAgBF,EAAoB,OAASA,EAAoB,MAAM,OAAS,EAClFA,EAAoB,MAAM,GAAG,UAC7B,EAWEG,GARuB,MAAMhB,EAAa,MAAM,CACpD,UAAWC,EAAO,gBAClB,uBAAwB,qBACxB,0BAA2B,CACzB,WAAYJ,CACd,CACF,CAAC,EAAE,QAAQ,GAEiC,OAAS,CAAC,EAGlDoB,EAAmB,EACvB,QAAWC,KAASF,EAAgB,CAClC,IAAMG,EAAUD,EAAM,QAGhBE,EAAe,MAAMpB,EAAa,IAAI,CAC1C,UAAWC,EAAO,QAClB,IAAK,CAAE,QAAAkB,EAAS,QAAAtB,CAAQ,CAC1B,CAAC,EAAE,QAAQ,EAEX,GAAIuB,EAAa,KAAM,CACrB,IAAMC,EAAwBD,EAAa,KAAK,uBAAyB,EACnEE,GAAqBF,EAAa,KAAK,oBAAsB,EAGnE,GAAIC,EAAwBjB,EAAY,CAEtC,IAAMmB,GAAmBD,GACnBE,GAAmBH,EAAwBlB,EAAM,YAAc,GAAK,GAAK,KAE3EqB,EAAkB,IACpBP,GAAoBM,IAAoBC,EAAkB,IAE9D,CACF,CACF,CAEA,IAAMC,EAAcT,EAAe,OAAS,EACxCC,EAAmBD,EAAe,OAClC,EAEJ,MAAO,CACL,QAAAnB,EACA,KAAMM,EAAM,KACZ,aAAcA,EAAM,cAAgB,EACpC,YAAAE,EACA,YAAAoB,EACA,mBAAAd,EACA,cAAAG,EACA,cAAAC,CACF,CACF,OAASW,EAAP,CACA,MAAA5B,EAAO,MAAM,kCAAmC,CAAE,MAAA4B,EAAO,QAAA7B,CAAQ,CAAC,EAC5D6B,CACR,CACF,EAGaC,GAAyB,SAAoC,CACxE7B,EAAO,MAAM,4BAA4B,EAEzC,GAAI,CAEF,GAAM,CAAC8B,EAAcC,EAAgBC,CAAoB,EAAI,MAAM,QAAQ,IAAI,CAC7E9B,EAAa,KAAK,CAChB,UAAWC,EAAO,OAClB,OAAQ,OACV,CAAC,EAAE,QAAQ,EAEXD,EAAa,KAAK,CAChB,UAAWC,EAAO,SAClB,OAAQ,OACV,CAAC,EAAE,QAAQ,EAEXD,EAAa,KAAK,CAChB,UAAWC,EAAO,gBAClB,OAAQ,OACV,CAAC,EAAE,QAAQ,CACb,CAAC,EAEK8B,EAAcH,EAAa,OAAS,EACpCI,EAAgBH,EAAe,OAAS,EACxCI,EAAsBH,EAAqB,OAAS,EAGpD1B,EAAa,KAAK,IAAI,EAAI,GAAK,GAAK,IAepC8B,IAbuB,MAAMlC,EAAa,KAAK,CACnD,UAAWC,EAAO,SAClB,iBAAkB,aAClB,yBAA0B,CACxB,MAAO,WACT,EACA,0BAA2B,CACzB,MAAOG,CACT,EACA,OAAQ,OACV,CAAC,EAAE,QAAQ,GAEsC,OAAS,GACT,GAG7C+B,EAAoB,EAQlBC,GALuB,MAAMpC,EAAa,KAAK,CACnD,UAAWC,EAAO,QAClB,MAAO,GACT,CAAC,EAAE,QAAQ,GAEiC,OAAS,CAAC,EAEtD,QAAWoC,KAAUD,EACfC,EAAO,sBAAwBjC,IACjC+B,GAAqBE,EAAO,oBAAsB,GAItD,IAAMC,EAAqBF,EAAe,OAAS,EAC9CD,EAAoBC,EAAe,OAAU,GAC9C,EAIAG,EAAc,EASZjC,IAN0B,MAAMN,EAAa,KAAK,CACtD,UAAWC,EAAO,SAClB,MAAO,IACP,qBAAsB,MACxB,CAAC,EAAE,QAAQ,GAEmC,OAAS,CAAC,GAAG,IAAKM,GAASA,EAAK,MAAQ,CAAC,EAEvF,OAAID,EAAa,OAAS,IAExBiC,EADgBjC,EAAa,OAAO,CAACG,EAAKC,IAASD,EAAMC,EAAM,CAAC,EAAIJ,EAAa,OACzD0B,GAGnB,CACL,YAAAD,EACA,cAAAC,EACA,oBAAAC,EACA,mBAAAC,EACA,mBAAAI,EACA,YAAAC,CACF,CACF,OAASb,EAAP,CACA,MAAA5B,EAAO,MAAM,mCAAoC,CAAE,MAAA4B,CAAM,CAAC,EACpDA,CACR,CACF,EAGac,GAA0B,MACrCC,EAA+B,CAAC,EAChCC,IACkB,CAClB,GAAI,CACF,IAAMC,EAAY,IAAI,KAChBC,EAAwC,CAAC,EAG/C,QAAWzC,KAASsC,EAClBG,EAAW,KACT,CACE,WAAY,eACZ,WAAY,CACV,CAAE,KAAM,UAAW,MAAOzC,EAAM,OAAQ,EACxC,CAAE,KAAM,YAAa,MAAOA,EAAM,IAAK,CACzC,EACA,MAAOA,EAAM,aACb,UAAWwC,EACX,KAAM,OACR,EACA,CACE,WAAY,cACZ,WAAY,CACV,CAAE,KAAM,UAAW,MAAOxC,EAAM,OAAQ,EACxC,CAAE,KAAM,YAAa,MAAOA,EAAM,IAAK,CACzC,EACA,MAAOA,EAAM,YACb,UAAWwC,EACX,KAAM,cACR,EACA,CACE,WAAY,cACZ,WAAY,CACV,CAAE,KAAM,UAAW,MAAOxC,EAAM,OAAQ,EACxC,CAAE,KAAM,YAAa,MAAOA,EAAM,IAAK,CACzC,EACA,MAAOA,EAAM,YACb,UAAWwC,EACX,KAAM,cACR,EACA,CACE,WAAY,qBACZ,WAAY,CACV,CAAE,KAAM,UAAW,MAAOxC,EAAM,OAAQ,EACxC,CAAE,KAAM,YAAa,MAAOA,EAAM,IAAK,CACzC,EACA,MAAOA,EAAM,mBACb,UAAWwC,EACX,KAAM,OACR,CACF,EAIED,GACFE,EAAW,KACT,CACE,WAAY,cACZ,MAAOF,EAAc,YACrB,UAAWC,EACX,KAAM,OACR,EACA,CACE,WAAY,gBACZ,MAAOD,EAAc,cACrB,UAAWC,EACX,KAAM,OACR,EACA,CACE,WAAY,sBACZ,MAAOD,EAAc,oBACrB,UAAWC,EACX,KAAM,OACR,EACA,CACE,WAAY,qBACZ,MAAOD,EAAc,mBACrB,UAAWC,EACX,KAAM,cACR,EACA,CACE,WAAY,qBACZ,MAAOD,EAAc,mBACrB,UAAWC,EACX,KAAM,cACR,EACA,CACE,WAAY,cACZ,MAAOD,EAAc,YACrB,UAAWC,EACX,KAAM,OACR,CACF,EAIF,IAAME,EAAY,GAClB,QAASC,EAAI,EAAGA,EAAIF,EAAW,OAAQE,GAAKD,EAAW,CACrD,IAAME,EAAQH,EAAW,MAAME,EAAGA,EAAID,CAAS,EAE/C,MAAMnD,GAAW,cAAc,CAC7B,UAAW,aACX,WAAYqD,CACd,CAAC,EAAE,QAAQ,CACb,CACF,OAASrB,EAAP,CACA5B,EAAO,MAAM,sCAAuC,CAAE,MAAA4B,CAAM,CAAC,CAE/D,CACF,EAEOsB,EAAQ,CACb,sBAAApD,GACA,uBAAA+B,GACA,wBAAAa,EACF,EGlXAS,IAMO,IAAMC,GAAc,MAAOC,GAAiC,CACjEC,EAAO,MAAM,iBAAkB,CAAE,QAASD,EAAM,OAAQ,CAAC,EAEzD,GAAI,CACF,aAAME,EAAa,IAAI,CACrB,UAAWC,EAAO,OAClB,KAAMH,EACN,oBAAqB,+BACvB,CAAC,EAAE,QAAQ,EAEJA,CACT,OAASI,EAAP,CAGA,MAFAH,EAAO,MAAM,uBAAwB,CAAE,MAAAG,EAAO,MAAAJ,CAAM,CAAC,EAEhDI,EAAc,OAAS,kCACpBC,EAAO,mBAAmBL,EAAM,IAAI,EAGtCI,CACR,CACF,EAGaE,EAAW,MAAOC,GAAoC,CACjEN,EAAO,MAAM,gBAAiB,CAAE,QAAAM,CAAQ,CAAC,EAEzC,GAAI,CACF,IAAMC,EAAS,MAAMN,EAAa,IAAI,CACpC,UAAWC,EAAO,OAClB,IAAK,CAAE,QAAAI,CAAQ,CACjB,CAAC,EAAE,QAAQ,EAEX,GAAI,CAACC,EAAO,KACV,MAAMH,EAAO,cAAcE,CAAO,EAGpC,OAAOC,EAAO,IAChB,OAASJ,EAAP,CAGA,MAFAH,EAAO,MAAM,sBAAuB,CAAE,MAAAG,EAAO,QAAAG,CAAQ,CAAC,EAEjDH,EAAc,OAAS,4BACpBC,EAAO,cAAcE,CAAO,EAG9BH,CACR,CACF,EAEaK,GAAiB,MAAOC,GAAwC,CAC3ET,EAAO,MAAM,wBAAyB,CAAE,KAAAS,CAAK,CAAC,EAE9C,GAAI,CACF,IAAMF,EAAS,MAAMN,EAAa,KAAK,CACrC,UAAWC,EAAO,OAClB,iBAAkB,gBAClB,yBAA0B,CACxB,QAAS,MACX,EACA,0BAA2B,CACzB,QAASO,CACX,EACA,MAAO,CACT,CAAC,EAAE,QAAQ,EAEX,OAAIF,EAAO,OAASA,EAAO,MAAM,OAAS,EACjCA,EAAO,MAAM,GAGf,IACT,OAASJ,EAAP,CACA,MAAAH,EAAO,MAAM,8BAA+B,CAAE,MAAAG,EAAO,KAAAM,CAAK,CAAC,EACrDN,CACR,CACF,EAGaO,GAAa,SAA8B,CACtDV,EAAO,MAAM,gBAAgB,EAE7B,GAAI,CAKF,OAJe,MAAMC,EAAa,KAAK,CACrC,UAAWC,EAAO,MACpB,CAAC,EAAE,QAAQ,GAEI,OAAS,CAAC,CAC3B,OAASC,EAAP,CACA,MAAAH,EAAO,MAAM,uBAAwB,CAAE,MAAAG,CAAM,CAAC,EACxCA,CACR,CACF,EAGaQ,GAAc,MAAOL,GAAmC,CACnEN,EAAO,MAAM,iBAAkB,CAAE,QAAAM,CAAQ,CAAC,EAE1C,GAAI,CACF,MAAML,EAAa,OAAO,CACxB,UAAWC,EAAO,OAClB,IAAK,CAAE,QAAAI,CAAQ,EACf,oBAAqB,2BACvB,CAAC,EAAE,QAAQ,CACb,OAASH,EAAP,CAGA,MAFAH,EAAO,MAAM,uBAAwB,CAAE,MAAAG,EAAO,QAAAG,CAAQ,CAAC,EAElDH,EAAc,OAAS,kCACpBC,EAAO,cAAcE,CAAO,EAG9BH,CACR,CACF,EAGaS,GAAwB,MAAON,EAAiBO,IAAqC,CAChGb,EAAO,MAAM,mCAAoC,CAAE,QAAAM,EAAS,UAAAO,CAAU,CAAC,EAEvE,GAAI,CACF,MAAMZ,EAAa,OAAO,CACxB,UAAWC,EAAO,OAClB,IAAK,CAAE,QAAAI,CAAQ,EACf,iBAAkB,qEAClB,0BAA2B,CACzB,OAAQ,EACR,MAAOO,CACT,EACA,oBAAqB,2BACvB,CAAC,EAAE,QAAQ,CACb,OAASV,EAAP,CAGA,MAFAH,EAAO,MAAM,mCAAoC,CAAE,MAAAG,EAAO,QAAAG,CAAQ,CAAC,EAE9DH,EAAc,OAAS,kCACpBC,EAAO,cAAcE,CAAO,EAG9BH,CACR,CACF,EAGaW,GAAc,MACzBR,EACAS,IACmB,CACnBf,EAAO,MAAM,iBAAkB,CAAE,QAAAM,EAAS,QAAAS,CAAQ,CAAC,EAGnD,IAAMC,EAA8B,CAAC,EAC/BC,EAAmD,CAAC,EACpDC,EAAiD,CAAC,EAUxD,GARA,OAAO,QAAQH,CAAO,EAAE,QAAQ,CAAC,CAACI,EAAKC,CAAK,IAAM,CAC5CA,IAAU,SACZJ,EAAkB,KAAK,IAAIG,QAAUA,GAAK,EAC1CF,EAAyB,IAAIE,KAASA,EACtCD,EAA0B,IAAIC,KAASC,EAE3C,CAAC,EAEGJ,EAAkB,SAAW,EAC/B,OAAOX,EAASC,CAAO,EAGzB,GAAI,CACF,aAAML,EAAa,OAAO,CACxB,UAAWC,EAAO,OAClB,IAAK,CAAE,QAAAI,CAAQ,EACf,iBAAkB,OAAOU,EAAkB,KAAK,IAAI,IACpD,yBAA0BC,EAC1B,0BAA2BC,EAC3B,oBAAqB,4BACrB,aAAc,MAChB,CAAC,EAAE,QAAQ,EAEJb,EAASC,CAAO,CACzB,OAASH,EAAP,CAGA,MAFAH,EAAO,MAAM,uBAAwB,CAAE,MAAAG,EAAO,QAAAG,CAAQ,CAAC,EAElDH,EAAc,OAAS,kCACpBC,EAAO,cAAcE,CAAO,EAG9BH,CACR,CACF,EAEOkB,EAAQ,CACb,YAAAvB,GACA,SAAAO,EACA,eAAAG,GACA,WAAAE,GACA,YAAAC,GACA,sBAAAC,GACA,YAAAE,EACF,ECjMS,IAAMQ,GAAkB,MAAOC,IACpCC,EAAO,MAAM,wBAAyB,CAAE,QAAAD,CAAQ,CAAC,EAGjD,MAAME,EAAgB,SAASF,CAAO,EAE/BG,EAAiB,sBAAsBH,CAAO,GAI1CI,GAAqB,SAAqC,CACrEH,EAAO,MAAM,2BAA2B,EAMxC,IAAMI,GAHS,MAAMH,EAAgB,WAAW,GAGjB,IAAII,GACjCH,EAAiB,sBAAsBG,EAAM,OAAO,CACtD,EAEA,OAAO,QAAQ,IAAID,CAAe,CACpC,EAEaE,EAAmB,UAC9BN,EAAO,MAAM,wBAAwB,EAC9BE,EAAiB,uBAAuB,GAIpCK,GAA2B,SAA2B,CACjEP,EAAO,MAAM,mCAAmC,EAEhD,GAAI,CAEF,IAAMQ,EAAgB,MAAMF,EAAiB,EAIvCG,GADS,MAAMR,EAAgB,WAAW,GACrB,MAAM,EAAG,EAAE,EAEhCS,EAAe,MAAM,QAAQ,IACjCD,EAAY,IAAIJ,GAASH,EAAiB,sBAAsBG,EAAM,OAAO,CAAC,CAChF,EAGA,MAAMH,EAAiB,wBAAwBQ,EAAcF,CAAa,EAE1ER,EAAO,KAAK,gCAAgC,CAC9C,OAASW,EAAP,CACAX,EAAO,MAAM,0CAA2C,CAAE,MAAAW,CAAM,CAAC,CAEnE,CACF,EAGaC,GAAsB,SAG7B,CACJZ,EAAO,MAAM,2BAA2B,EAGxC,IAAMQ,EAAgB,MAAMF,EAAiB,EAMvCO,GAHS,MAAMZ,EAAgB,WAAW,GAGnB,MAAM,EAAG,EAAE,EAGlCS,EAAe,MAAM,QAAQ,IACjCG,EAAc,IAAIR,GAASH,EAAiB,sBAAsBG,EAAM,OAAO,CAAC,CAClF,EAGA,OAAAK,EAAa,KAAK,CAACI,EAAGC,IAAMA,EAAE,aAAeD,EAAE,YAAY,EAEpD,CACL,OAAQN,EACR,OAAQE,CACV,CACF,EAEOM,GAAQ,CACb,gBAAAlB,GACA,mBAAAK,GACA,iBAAAG,EACA,yBAAAC,GACA,oBAAAK,EACF,EN/FK,IAAMK,GAAU,MACrBC,EACAC,IACkC,CAClCC,EAAO,KAAK,+BAAgC,CAAE,MAAAF,CAAM,CAAC,EAErD,GAAI,CACF,aAAMG,GAAc,yBAAyB,EAE7CD,EAAO,KAAK,+BAA+B,EAEpC,CACL,QAAS,EACX,CACF,OAASE,EAAP,CACA,OAAAF,EAAO,MAAM,mCAAoC,CAAE,MAAAE,CAAM,CAAC,EAGnD,CACL,QAAS,EACX,CACF,CACF",
  "names": ["ENV", "STAGE", "TABLES", "BUCKETS", "LIMITS", "ERROR_CODES", "HTTP_STATUS", "init_constants", "__esmMin", "config_exports", "__export", "config", "config_default", "baseConfig", "envConfigs", "environmentConfig", "init_config", "__esmMin", "init_constants", "LIMITS", "ENV", "STAGE", "metrics_aggregator_exports", "__export", "handler", "__toCommonJS", "import_aws_sdk", "init_config", "options", "config", "dynamoClient", "init_constants", "config", "LOG_LEVEL_MAP", "currentLogLevel", "config", "formatLogMessage", "level", "message", "data", "timestamp", "requestId", "logObject", "logMessage", "Logger", "logger", "logger_default", "init_constants", "AppError", "code", "message", "statusCode", "details", "Errors", "ERROR_CODES", "HTTP_STATUS", "resource", "id", "topicId", "name", "messageId", "size", "maxSize", "groupId", "import_aws_sdk", "cloudWatch", "AWS", "calculateTopicMetrics", "topicId", "logger", "topicResult", "dynamoClient", "TABLES", "Errors", "topic", "oneHourAgo", "publishRate", "messageSizes", "item", "totalSize", "sum", "size", "averageMessageSize", "oldestMessageResult", "newestMessageResult", "oldestMessage", "newestMessage", "consumerGroups", "totalConsumeRate", "group", "groupId", "offsetResult", "lastConsumedTimestamp", "lastSequenceNumber", "consumedMessages", "hoursSinceStart", "consumeRate", "error", "calculateSystemMetrics", "topicsResult", "messagesResult", "consumerGroupsResult", "totalTopics", "totalMessages", "totalConsumerGroups", "averagePublishRate", "totalConsumeCount", "consumerSample", "offset", "averageConsumeRate", "storageUsed", "pushMetricsToCloudWatch", "topicMetrics", "systemMetrics", "timestamp", "metricData", "batchSize", "i", "batch", "metric_repository_default", "init_constants", "createTopic", "topic", "logger", "dynamoClient", "TABLES", "error", "Errors", "getTopic", "topicId", "result", "getTopicByName", "name", "listTopics", "deleteTopic", "incrementMessageCount", "timestamp", "updateTopic", "updates", "updateExpressions", "expressionAttributeNames", "expressionAttributeValues", "key", "value", "topic_repository_default", "getTopicMetrics", "topicId", "logger_default", "topic_repository_default", "metric_repository_default", "getAllTopicMetrics", "metricsPromises", "topic", "getSystemMetrics", "collectAndPublishMetrics", "systemMetrics", "topicSample", "topicMetrics", "error", "getDashboardMetrics", "limitedTopics", "a", "b", "metric_service_default", "handler", "event", "context", "logger_default", "metric_service_default", "error"]
}
